"""
Here we load the results generated by running `run_one_comparison.py`. This script outputs one result file per
comparison. We'll load them in and analyse the combined results.
"""

from methylation import loader
from plotting import venn, common, bar
import pandas as pd
from utils import output, setops, log
import numpy as np
import pickle
from matplotlib import pyplot as plt, gridspec
import seaborn as sns
import os
import re
import csv
from ast import literal_eval as make_tuple
from scipy import stats
import itertools
from settings import INTERMEDIATE_DIR


logger = log.get_console_logger("analyse_residual_dmrs")


def get_dmr_number_direction(res_dict, fdr=0.01):
    out = {}
    for k, this_res in res_dict.items():
        ix1 = this_res.loc[:, 'median_delta'] < 0
        ix2 = this_res.loc[:, 'padj'] < fdr
        out[k] = {
            'Hypermethylated': ((~ix1) & ix2).sum(),
            'Hypomethylated': (ix1 & ix2).sum(),
        }
    return pd.DataFrame(out).transpose()


def get_dmr_cid_direction(res_dict, fdr=0.01):
    out = {}
    for k, this_res in res_dict.items():
        ix1 = this_res.loc[:, 'median_delta'] < 0
        ix2 = this_res.loc[:, 'padj'] < fdr
        out[k] = {
            'Hypermethylated': this_res.loc[((~ix1) & ix2)].index,
            'Hypomethylated': this_res.loc[(ix1 & ix2)].index,
        }
    return out


def core_dmrs(ipsc_vs_esc, fdr=0.01):
    """
    For each result, get the set of core DMRs that are present in all ref comparisons
    :return:
    """
    keep_cols = ['median_2', 'padj', 'median_delta']
    core_tbl = {}
    for k1, v1 in ipsc_vs_esc.items():
        core_tbl[k1] = {}
        for k2, v2 in v1.items():
            for k3, df in v2.items():
                this_ix = df.index[df.padj < fdr]
                the_key = k3.split('-')[0]
                if the_key in core_tbl[k1]:
                    # reduce to intersection
                    this_ix = this_ix.intersection(core_tbl[k1][the_key].index)
                    core_tbl[k1][the_key] = core_tbl[k1][the_key].loc[this_ix]
                else:
                    core_tbl[k1][the_key] = df.loc[this_ix]
                    # drop unneeded copies of columns that will be reinserted below
                    for c in keep_cols:
                        core_tbl[k1][the_key].drop(c, axis=1, inplace=True)

                # either way, add columns
                for c in keep_cols:
                    core_tbl[k1][the_key].insert(core_tbl[k1][the_key].shape[1], '%s_%s' % (c, k2), df.loc[this_ix, c])

        # run back through and check that direction is consistent
        for the_key, df in core_tbl[k1].items():
            the_sign = None
            for the_col in df.columns[df.columns.str.contains('median_delta_')]:
                if the_sign is None:
                    the_sign = np.sign(df[the_col])
                else:
                    the_sign = the_sign == np.sign(df[the_col])
            if the_sign.sum() != the_sign.size:
                print "Of the %d consistent DMRs in comparison %s / %s, %d have different direction and will be removed." % (
                    the_sign.size,
                    k1,
                    the_key,
                    (~the_sign).sum()
                )
            core_tbl[k1][the_key] = core_tbl[k1][the_key].loc[the_sign]

    return core_tbl


def classify_dmrs_residual_denovo(core_tbl, parental, exclude=None):
    """

    :param core_tbl: From core_dmrs() function (e.g. iPSC vs ESC).
    :param parental: Raw results from parental comparison (e.g. iPSC vs FB).
    :param exclude: If present, this contains probes to exclude from the analysis.
    :return:
    """
    res = {}

    for k1, this_tbl in core_tbl.items():
        if k1 not in parental:
            logger.warning("Sample %s has no matching parental sample. Skipping", k1)
            continue

        if exclude is not None:
            this_tbl = this_tbl.loc[this_tbl.index.difference(exclude)]
        mean_median_delta = this_tbl.loc[:, this_tbl.columns.str.contains('median_delta_')].mean(axis=1)

        # look for the same DMRs in the parental comparison
        this_par = parental[k1]
        p_ix = this_par.index.intersection(this_tbl.index)
        mmd_lookup = mean_median_delta.loc[p_ix]

        res[k1] = this_tbl.copy()
        clas = pd.Series('partial', index=this_tbl.index)

        # de novo: DM in (A vs B) AND (A vs C) with same direction
        ix = (mmd_lookup > 0.) & (this_par.loc[p_ix, 'median_delta'] > 0.)
        clas.loc[ix.index[ix]] = 'hyper_de_novo'
        ix = (mmd_lookup < 0.) & (this_par.loc[p_ix, 'median_delta'] < 0.)
        clas.loc[ix.index[ix]] = 'hypo_de_novo'

        # residual: DM in (A vs B) AND NOT in (A vs C)
        not_p_ix = ~this_tbl.index.isin(this_par.index)
        mmd_lookup = mean_median_delta.loc[not_p_ix]
        ix = (mmd_lookup > 0)
        clas.loc[ix.index[ix]] = 'hyper_residual'
        ix = (mmd_lookup < 0)
        clas.loc[ix.index[ix]] = 'hypo_residual'

        res[k1].insert(2, 'classification', clas)

    return res


def jitter_points(x, spacing_buffer=1, jitter_step=0.02):
    curr = 0
    prev = -1e9
    out = np.zeros_like(x, dtype=float)
    for i in np.argsort(x):
        if np.abs(x[i] - prev) > spacing_buffer:
            curr = max(0., curr - jitter_step)
        else:
            curr += jitter_step
        out[i] = curr
        prev = x[i]
    return out


def scatter_cluster_mvals_classified(
    core_dmrs_classified,
    mdat,
    clusters,
    samples_x,
    samples_y,
    samples_base,
    figsize=(5, 5),
    types=('hyper_residual', 'hypo_residual', 'hyper_de_novo', 'hypo_de_novo'),
    n_other=50
):
    """
    Generate a scatterplot showing (X - base) against (Y - base), where all three are median values across the probes
    in a DMR cluster.
    For example, X = fibroblast, Y = iPSC, base = ESC.
    :param core_dmrs_classified: ONE element from the output of classify_dmrs_residual_denovo(). This is a
    pd.DataFrame with one row per DMR. It must have the column `classification`, which is used to identify different
    cluster types.
    :param mdat: The full matrix of methylation (M) values. Must have the columns listed in samples_x, samples_y,
    samples_base
    :param clusters: DmrResults object containing clusters. These don't need to have been tested, we just need the
    probe IDs corresponding to each cluster.
    :param samples_x: Either a string or an iterable of sample names.
    :param samples_y: Either a string or an iterable of sample names.
    :param samples_base: Either a string or an iterable of sample names.
    :param figsize:
    :param types:
    :param n_other:
    :return:
    """
    if not hasattr(samples_x, '__iter__'):
        samples_x = [samples_x]
    if not hasattr(samples_y, '__iter__'):
        samples_y = [samples_y]
    if not hasattr(samples_base, '__iter__'):
        samples_base = [samples_base]

    dat_x = mdat.loc[:, samples_x].median(axis=1)
    dat_y = mdat.loc[:, samples_y].median(axis=1)
    dat_base = mdat.loc[:, samples_base].median(axis=1)

    colours = common.get_best_cmap(len(types))
    fig = plt.figure(figsize=figsize)
    ax = fig.add_subplot(111)
    all_cids = set()

    for i, typ in enumerate(types):
        this = core_dmrs_classified.loc[core_dmrs_classified.classification == typ]
        # for each cluster, we need to regenerate the required median values
        all_cids.update(this.index)
        pids = [clusters.clusters[t].pids for t in this.index]

        x_vals = np.array([dat_x.loc[p].median() for p in pids])
        y_vals = np.array([dat_y.loc[p].median() for p in pids])
        base_vals = np.array([dat_base.loc[p].median() for p in pids])

        ax.scatter(
            x_vals - base_vals,
            y_vals - base_vals,
            facecolors=colours[i],
            edgecolors='k',
            label=typ.replace('_', ' ').capitalize(),
            zorder=2.
        )

    # add random other clusters
    other_cids = sorted(set(clusters.clusters.keys()).difference(all_cids))
    np.random.shuffle(other_cids)
    other_cids = other_cids[:n_other]
    pids = [clusters.clusters[t].pids for t in other_cids]

    x_vals = np.array([dat_x.loc[p].median() for p in pids])
    y_vals = np.array([dat_y.loc[p].median() for p in pids])
    base_vals = np.array([dat_base.loc[p].median() for p in pids])

    ax.scatter(
        x_vals - base_vals,
        y_vals - base_vals,
        facecolors='w',
        edgecolors='k',
        label='Other clusters',
        zorder=1.
    )

    ax.legend(loc='upper left', frameon=True, framealpha=0.7, facecolor='w')
    ax.axvline(0., c='k', lw=1., zorder=1, alpha=0.75)
    ax.axhline(0., c='k', lw=1., zorder=1, alpha=0.75)
    ax.set_aspect('equal')

    # diagonal line
    lims = [
        np.min([ax.get_xlim(), ax.get_ylim()]),  # min of both axes
        np.max([ax.get_xlim(), ax.get_ylim()]),  # max of both axes
    ]
    ax.plot(lims, lims, 'k-', alpha=0.75, zorder=0, lw=1.)

    # ax.set_xlabel('M value of FB relative to ESC')
    # ax.set_ylabel('M value of iPSC relative to ESC')
    # fig.tight_layout()
    return fig, ax


def scatter_probe_mvals_classified(
    core_dmrs_classified,
    mdat,
    clusters,
    samples_x,
    samples_y,
    samples_base,
    figsize=(5, 5),
    types=('hyper_residual', 'hypo_residual', 'hyper_de_novo', 'hypo_de_novo'),
    n_other=50
):
    if not hasattr(samples_x, '__iter__'):
        samples_x = [samples_x]
    if not hasattr(samples_y, '__iter__'):
        samples_y = [samples_y]
    if not hasattr(samples_base, '__iter__'):
        samples_base = [samples_base]

    dat_x = mdat.loc[:, samples_x].median(axis=1)
    dat_y = mdat.loc[:, samples_y].median(axis=1)
    dat_base = mdat.loc[:, samples_base].median(axis=1)

    colours = common.get_best_cmap(len(types))
    fig = plt.figure(figsize=figsize)
    ax = fig.add_subplot(111)
    all_pids = set()

    for i, typ in enumerate(types):
        this = core_dmrs_classified.loc[core_dmrs_classified.classification == typ]
        if len(this) == 0:
            pids = []
        else:
            # for each cluster, we need to regenerate the required median values
            pids = setops.reduce_union(*[clusters.clusters[t].pids for t in this.index])
        all_pids.update(pids)

        x_vals = dat_x.loc[pids]
        y_vals = dat_y.loc[pids]
        base_vals = dat_base.loc[pids]

        ax.scatter(
            x_vals - base_vals,
            y_vals - base_vals,
            facecolors=colours[i],
            edgecolors='k',
            label=typ.replace('_', ' ').capitalize(),
            zorder=2.
        )

    # add random other clusters
    other_pids = mdat.index.difference(all_pids).tolist()
    np.random.shuffle(other_pids)
    pids = other_pids[:n_other]

    x_vals = dat_x.loc[pids]
    y_vals = dat_y.loc[pids]
    base_vals = dat_base.loc[pids]

    ax.scatter(
        x_vals - base_vals,
        y_vals - base_vals,
        facecolors='w',
        edgecolors='k',
        label='Other probes',
        zorder=1.
    )

    ax.legend(loc='upper left', frameon=True, framealpha=0.7, facecolor='w')
    ax.axvline(0., c='k', lw=1., zorder=1, alpha=0.75)
    ax.axhline(0., c='k', lw=1., zorder=1, alpha=0.75)
    ax.set_aspect('equal')

    # diagonal line
    lims = [
        np.min([ax.get_xlim(), ax.get_ylim()]),  # min of both axes
        np.max([ax.get_xlim(), ax.get_ylim()]),  # max of both axes
    ]
    ax.plot(lims, lims, 'k-', alpha=0.75, zorder=0, lw=1.)

    # ax.set_xlabel('M value of FB relative to ESC')
    # ax.set_ylabel('M value of iPSC relative to ESC')
    # fig.tight_layout()
    return fig, ax


if __name__ == "__main__":
    basedir = os.path.join(INTERMEDIATE_DIR, "assess_reprog_alt1")
    indir = os.path.join(basedir, "results")
    outdir = output.unique_output_dir('assess_reprog_alt1')
    names = [t.replace('.csv', '') for t in os.listdir(indir) if '.csv' in t]

    fdr = 0.01

    colours = {
        'Hypermethylated': '#e09191',  # red
        'Hypomethylated': '#91e097',  # green
    }

    colour_by_pid = {
        '019': '#7fc97f',
        '030': '#beaed4',
        '031': '#fdc086',
        '050': '#ffff99',
        '054': '#386cb0',
    }

    # split into comparison types
    ipsc_vs_fb_names = [t for t in names if re.match(r'iPSC[^-]*-FB.*', t)]
    ipsc_vs_esc_names = [t for t in names if re.match(r'iPSC[^-]*-ESC.*', t)]
    insc_vs_ipsc_names = [t for t in names if re.match(r'iNSC[^-]*-iPSC.*', t)]
    esc_vs_esc_names = [t for t in names if re.match(r'ESC[^-]*-ESC.*', t)]

    all_types = [
        ipsc_vs_esc_names,
        ipsc_vs_fb_names,
        insc_vs_ipsc_names,
        esc_vs_esc_names
    ]

    if sum([len(t) for t in all_types]) != len(names):
        logger.warn("Some comparisons not covered")

    # now load the actual results
    ipsc_ours_regex = r'iPSC0[135].*'
    fb_ours_regex = r'FB0[135]*'
    ipsc_e6194_regex = r'iPSCHEL[^-]*'
    fb_e6194_regex = r'FB27_HFF'
    ipsc_hipsci_regex = r'iPSCHPS[^-]*'
    ipsc_banov_regex = r'iPSCNA[0-9].*'
    esc_encode_regex = r'ESCH7 hESC'
    esc_e6194_regex = r'ESCH9_p50'
    insc_ours_regex = r'iNSC0[135].*'

    ipsc_regex = {
        'ours': ipsc_ours_regex,
        'e6194': ipsc_e6194_regex,
        'hipsci': ipsc_hipsci_regex,
        'banov': ipsc_banov_regex
    }

    fb_regex = {
        'ours': fb_ours_regex,
        'e6194': fb_e6194_regex
    }

    esc_regex = {
        'encode': esc_encode_regex,
        'e6194': esc_e6194_regex
    }

    insc_regex = {
        'ours': insc_ours_regex
    }

    ipsc_vs_fb = {}
    for k1, v1 in ipsc_regex.items():
        for k2, v2 in fb_regex.items():
            the_regex = re.compile("%s-%s" % (v1, v2))
            the_names = [t for t in ipsc_vs_fb_names if re.match(the_regex, t)]

            ipsc_vs_fb.setdefault(k1, {})[k2] = dict([
                (t, pd.read_csv(os.path.join(indir, "%s.csv" % t), header=0, index_col=0)) for t in the_names
            ])

    ipsc_vs_esc = {}
    for k1, v1 in ipsc_regex.items():
        for k2, v2 in esc_regex.items():
            the_regex = re.compile("%s-%s" % (v1, v2))
            the_names = [t for t in ipsc_vs_esc_names if re.match(the_regex, t)]

            ipsc_vs_esc.setdefault(k1, {})[k2] = dict([
                (t, pd.read_csv(os.path.join(indir, "%s.csv" % t), header=0, index_col=0)) for t in the_names
            ])

    insc_vs_ipsc = {}
    for k1, v1 in insc_regex.items():
        for k2, v2 in ipsc_regex.items():
            the_regex = re.compile("%s-%s" % (v1, v2))
            the_names = [t for t in insc_vs_ipsc_names if re.match(the_regex, t)]

            insc_vs_ipsc.setdefault(k1, {})[k2] = dict([
                (t, pd.read_csv(os.path.join(indir, "%s.csv" % t), header=0, index_col=0)) for t in the_names
            ])

    esc_vs_esc = {}
    for k1, v1 in esc_regex.items():
        for k2, v2 in esc_regex.items():
            the_regex = re.compile("%s-%s" % (v1, v2))
            the_names = [t for t in esc_vs_esc_names if re.match(the_regex, t)]

            esc_vs_esc.setdefault(k1, {})[k2] = dict([
                (t, pd.read_csv(os.path.join(indir, "%s.csv" % t), header=0, index_col=0)) for t in the_names
            ])

    # get lists of sample names
    ipsc_samples = {}
    fb_samples = {}
    esc_samples = {}
    insc_samples = {}

    for i in ipsc_vs_fb:
        for j in ipsc_vs_fb[i]:
            all_ipsc = sorted(set([t.split('-')[0] for t in ipsc_vs_fb[i][j]]))
            all_fb = sorted(set([t.split('-')[1] for t in ipsc_vs_fb[i][j]]))
            ipsc_samples[i] = all_ipsc
            fb_samples[j] = all_fb

    for i in ipsc_vs_esc:
        for j in ipsc_vs_esc[i]:
            all_esc = sorted(set([t.split('-')[1] for t in ipsc_vs_esc[i][j]]))
            esc_samples[j] = all_esc

    for i in insc_vs_ipsc:
        all_insc = sorted(set([t.split('-')[0] for t in insc_vs_ipsc[i]['ours']]))
        insc_samples[i] = all_insc

    ## iPSC vs FB ##

    # 1) is there any obvious increased similarity between matched and unmatached comparisons in our lines?
    t = get_dmr_number_direction(ipsc_vs_fb['ours']['ours'])

    matched = {}
    unmatched = {}

    for k in t.index:
        p1, p2 = k.replace('iPSC', '').replace('FB', '').split('-')
        if p2 == p1:
            the_dict = matched
            loc = 0.
            scale = 0.
        else:
            the_dict = unmatched
            loc = 1.
            scale = 0.05

        y = t.loc[k, 'Hypomethylated']
        the_dict.setdefault('hypo', {}).setdefault(p1, []).append(y)
        y = t.loc[k, 'Hypermethylated']
        the_dict.setdefault('hyper', {}).setdefault(p1, []).append(y)

    spacings = {
        'hypo': 2,
        'hyper': 7,
    }
    fig, axs = plt.subplots(1, 2, sharex=True)
    y = {}
    c = {}
    for pid in unmatched['hypo'].keys():
        for i, k in enumerate(['hypo', 'hyper']):
            ax = axs[i]
            this_y = unmatched[k][pid]
            y.setdefault(k, []).extend(this_y)
            this_c = [colour_by_pid[pid]] * len(this_y)
            c.setdefault(k, []).extend(this_c)
            ax.scatter(
                [0.],
                matched[k][pid],
                marker='o',
                facecolor=colour_by_pid[pid],
                s=40,
                edgecolor='k',
                linewidths=1.0,
                label=pid
            )

    for i, k in enumerate(['hypo', 'hyper']):
        ax = axs[i]
        this_y = y[k]
        this_x = jitter_points(this_y, spacing_buffer=spacings[k], jitter_step=0.05) + 1.
        this_c = c[k]
        ax.scatter(
            this_x,
            this_y,
            marker='o',
            facecolors=this_c,
            s=40,
            edgecolor='k',
            linewidths=1.0,
        )

    for ax in axs:
        ax.set_xlim([-.5, 1.5])
        ax.set_xticks([0, 1])
        ax.set_xticklabels(['Matched', 'Cross-compared'])
        ax.set_ylim([0, ax.get_ylim()[1]])

    axs[0].set_title("Hypomethylated DMRs")
    axs[0].set_ylabel("Number of DMRs")
    axs[1].set_title("Hypermethylated DMRs")
    axs[1].legend(loc='lower right', facecolor='w', framealpha=0.6, frameon=True)

    fig.tight_layout()
    fig.savefig(os.path.join(outdir, "our_ipsc_vs_our_fb_number_dmrs.png"), dpi=200)

    # confidence intervals
    alpha = 0.95
    for pid in matched['hypo']:
        for k in ['hypo', 'hyper']:
            arr = unmatched[k][pid]
            ci = stats.norm.interval(alpha, loc=np.mean(arr), scale=np.std(arr, ddof=1))
            if ci[0] <= matched[k][pid][0] <= ci[1]:
                pass
            else:
                print "%s %s %s -> %d" % (pid, k, str(ci), matched[k][pid][0])
                print "Patient %s, %s DMRs, reject H0 at %.1f%% level." % (pid, k, alpha * 100)

    # 2) numbers and direction

    # to_plot nesting format: iNSC then FB
    k_our_fb = 'Our data (n=%d)' % len(fb_samples['ours'])
    # k_e6194_fb = 'E-MTAB-6194 (n=%d)' % len(fb_samples['e6194'])
    k_e6194_fb = 'Weltner et al. (n=%d)' % len(fb_samples['e6194'])
    k_our_ipsc = 'Our data (n=%d)' % len(ipsc_samples['ours'])
    # k_e6194_ipsc = 'E-MTAB-6194 (n=%d)' % len(ipsc_samples['e6194'])
    k_e6194_ipsc = 'Weltner et al. (n=%d)' % len(ipsc_samples['e6194'])
    k_hipsci_ipsc = 'HipSci (n=%d)' % len(ipsc_samples['hipsci'])
    k_banov_ipsc = 'Banovich (n=%d)' % len(ipsc_samples['banov'])

    to_plot = {
        k_our_ipsc: {
            k_our_fb: ipsc_vs_fb['ours']['ours'],
            k_e6194_fb: ipsc_vs_fb['ours']['e6194']
        },
        k_e6194_ipsc: {
            k_our_fb: ipsc_vs_fb['e6194']['ours'],
            k_e6194_fb: ipsc_vs_fb['e6194']['e6194'],
        },
        k_hipsci_ipsc: {
            k_our_fb: ipsc_vs_fb['hipsci']['ours'],
            k_e6194_fb: ipsc_vs_fb['hipsci']['e6194'],
        },
        k_banov_ipsc: {
            k_our_fb: ipsc_vs_fb['banov']['ours'],
            k_e6194_fb: ipsc_vs_fb['banov']['e6194'],
        }
    }


    fig_hypo, axs_hypo = plt.subplots(len(to_plot), len(to_plot.values()[0]), sharex=True, sharey=True, figsize=(3.5, 6))
    fig_hyper, axs_hyper = plt.subplots(len(to_plot), len(to_plot.values()[0]), sharex=True, sharey=True, figsize=(3.5, 6))

    medianprops = dict(linestyle='-', linewidth=2., color='k')

    ymax = {}

    for i, (k1, d) in enumerate(to_plot.items()):
        axs_hyper[i, 0].set_ylabel(k1)
        axs_hypo[i, 0].set_ylabel(k1)
        for j, (k2, obj) in enumerate(d.items()):
            t = get_dmr_number_direction(obj)
            for axs, k3 in zip([axs_hyper, axs_hypo], ['Hypermethylated', 'Hypomethylated']):
                this_y = t.loc[:, k3].values
                this_x = np.random.normal(scale=0.05, size=this_y.size) + 1
                ymax[k3] = max(ymax.get(k3, 0), this_y.max())
                axs[-1, j].set_xlabel(k2)
                ax = axs[i, j]
                bplot = ax.boxplot(
                    this_y,
                    vert=True,
                    patch_artist=True,
                    medianprops=medianprops,
                    widths=0.7
                )
                ax.scatter(this_x, this_y, facecolor='none', edgecolor='k', linewidths=1., s=40, marker='o', zorder=5)
                ax.set_xticks([])
                plt.setp(bplot['boxes'], facecolor=colours[k3])

    axs_hyper[0, 0].set_ylim([0, ymax['Hypermethylated'] * 1.1])
    axs_hypo[0, 0].set_ylim([0, ymax['Hypomethylated'] * 1.1])
    fig_hyper.tight_layout()
    fig_hypo.tight_layout()
    fig_hyper.savefig(os.path.join(outdir, "iPSC_vs_FB_number_dmr_hyper.png"), dpi=200)
    fig_hypo.savefig(os.path.join(outdir, "iPSC_vs_FB_number_dmr_hypo.png"), dpi=200)

    # 3) Overlap of core DMRs in each comparison type
    # Remove (n=x) from labels to save space on the plot
    to_plot2 = {}

    for k1 in to_plot:
        for k2 in to_plot[k1]:
            new_k1 = re.sub(r" \(n=[0-9]*\)", "", k1)
            new_k2 = re.sub(r" \(n=[0-9]*\)", "", k2)
            to_plot2.setdefault(new_k1, {})[new_k2] = to_plot[k1][k2]

    members = {'hypo': {}, 'hyper': {}}
    for i, (k1, d) in enumerate(to_plot2.items()):
        for j, (k2, obj) in enumerate(d.items()):
            t = get_dmr_cid_direction(obj)
            hypo_cid = setops.reduce_intersection(*[x['Hypomethylated'] for x in t.values()])
            hyper_cid = setops.reduce_intersection(*[x['Hypermethylated'] for x in t.values()])
            members['hypo'][(k1, k2)] = hypo_cid
            members['hyper'][(k1, k2)] = hyper_cid

    ks = sorted(members['hypo'].keys())
    upset_dat = [members['hypo'][k] for k in ks]
    upset_lbl = ["%s - %s" % t for t in ks]
    ups = venn.upset_set_size_plot(
        upset_dat, upset_lbl, n_plot=25
    )
    ups['gs'].update(wspace=0.7)
    ups['axes']['set_size'].set_xlabel('Number hypomethylated DMRs in iPSC')
    ups['axes']['main'].set_ylabel('Number DMRs')
    ups['figure'].savefig(os.path.join(outdir, "ipsc_vs_fb_core_hypo_dmr_upset.png"), dpi=200)

    ks = sorted(members['hyper'].keys())
    upset_dat = [members['hyper'][k] for k in ks]
    upset_lbl = ["%s - %s" % t for t in ks]
    ups = venn.upset_set_size_plot(
        upset_dat, upset_lbl, n_plot=25
    )
    ups['gs'].update(wspace=0.7)
    ups['axes']['set_size'].set_xlabel('Number hypermethylated DMRs in iPSC')
    ups['axes']['main'].set_ylabel('Number DMRs')
    ups['figure'].savefig(os.path.join(outdir, "ipsc_vs_fb_core_hyper_dmr_upset.png"), dpi=200)

    ## iPSC vs ESC ##
    # 1) Numbers and direction

    to_plot = {
        k_our_ipsc: ipsc_vs_esc['ours'],
        k_e6194_ipsc: ipsc_vs_esc['e6194'],
        k_hipsci_ipsc: ipsc_vs_esc['hipsci'],
        k_banov_ipsc: ipsc_vs_esc['banov'],
    }

    lbl_map = {
        'encode': 'Encode',
        'e6194': 'Weltner et al.'
    }

    ax1 = None
    gs = plt.GridSpec(2 * len(to_plot), 3)
    fig = plt.figure(figsize=(6, 2 * len(to_plot)))
    axs = np.empty((len(to_plot), 3), dtype=object)
    colours = ['#e09191', '#91e097']  # red, green (hyper, hypo)

    medianprops = dict(linestyle='-', linewidth=2., color='k')

    for i, (k1, obj) in enumerate(to_plot.items()):
        ax1 = None
        ax_i = (2 * i)
        u_hypo = {}
        u_hyper = {}
        for j, (r, s) in enumerate(esc_samples.items()):
            t = get_dmr_number_direction(obj[r])
            u = get_dmr_cid_direction(obj[r])

            if ax1 is None:
                ax = fig.add_subplot(gs[ax_i:(ax_i + 2), j])
                ax1 = ax
            else:
                ax = fig.add_subplot(gs[ax_i:(ax_i + 2), j], sharex=ax1, sharey=ax1)
                # ax = fig.add_subplot(gs[ax_i:(ax_i + 2), j], sharex=ax1)

            if j != 0:
                plt.setp(
                    ax.yaxis.get_ticklabels(), visible=False
                )

            axs[i, j] = ax
            u_hypo[r] = setops.reduce_intersection(*[x['Hypomethylated'] for k, x in u.items()])
            u_hyper[r] = setops.reduce_intersection(*[x['Hypermethylated'] for k, x in u.items()])

            sns.boxplot(
                data=t.values,
                orient='v',
                width=0.7,
                ax=ax
            )
            boxes = ax.artists

            ax.set_xticks([])

            for p, c in zip(boxes, colours):
                p.set_facecolor(c)

        # add third column with Venn diagrams
        ax = fig.add_subplot(gs[ax_i + 1, 2], facecolor='none', frame_on=False, xticks=[], yticks=[])
        set_labels = None
        if i == (len(to_plot) - 1):
            set_labels = [lbl_map[x] for x in u_hypo.keys()]
        v = venn.venn_diagram(
            *u_hypo.values(),
            ax=ax,
            set_labels=set_labels,
            set_colors=[colours[1]] * 2
        )
        if set_labels is not None:
            plt.setp(v[0].set_labels, fontsize=10)

        ax = fig.add_subplot(gs[ax_i, 2], facecolor='none', frame_on=False, xticks=[], yticks=[])
        set_labels = None
        v = venn.venn_diagram(
            *u_hyper.values(),
            ax=ax,
            set_labels=set_labels,
            set_colors=[colours[0]] * 2,
            alpha=0.7
        )

    for i, (k1, obj) in enumerate(to_plot.items()):
        axs[i, 0].set_ylabel(k1)

    for j, k in enumerate(to_plot.values()[0].keys()):
        axs[-1, j].set_xlabel(lbl_map[k])

    gs.update(bottom=0.05, top=0.96, right=0.95, wspace=0.05)
    fig.savefig(os.path.join(outdir, "iPSC_vs_ESC_number_dmr.png"), dpi=200)

    # plot showing the number of DMRs (split by direction)
    # we can try doing this by violin plot or similar
    n_core = {}
    n_core_hypo = {}
    n_core_hyper = {}
    core = {}
    core_discordant = {}
    core_hypo = {}
    core_hyper = {}
    for i, (k1, obj) in enumerate(to_plot.items()):
        u_hypo = {}
        u_hyper = {}
        u_all = {}
        for j, (r, s) in enumerate(esc_samples.items()):
            t = get_dmr_number_direction(obj[r])
            u = get_dmr_cid_direction(obj[r])
            u_hypo[r] = dict([(k.split('-')[0], x['Hypomethylated']) for k, x in u.items()])
            u_hyper[r] = dict([(k.split('-')[0], x['Hypermethylated']) for k, x in u.items()])
            u_all[r] = {}
            for k2 in u_hyper[r].keys():
                u_all[r][k2] = u_hypo[r][k2].union(u_hyper[r][k2])
                if len(u_hypo[r][k2].intersection(u_hyper[r][k2])) > 0:
                    print "Warning! Ref %s, comparison %s. %d DMRs are marked as BOTH hypo and hyper." % (
                        r,
                        k2,
                        len(u_hypo[r][k2].intersection(u_hyper[r][k2]))
                    )

        core_hypo[k1] = dict([
            (k, setops.reduce_intersection(*[u_hypo[r][k] for r in esc_samples])) for k in u_hypo.values()[0]
        ])
        core_hyper[k1] = dict([
            (k, setops.reduce_intersection(*[u_hyper[r][k] for r in esc_samples])) for k in u_hyper.values()[0]
        ])
        # for ALL core DMRs, use hypo and hyper rather than u_all
        core[k1] = dict([
            (k, core_hypo[k1][k].union(core_hyper[k1][k])) for k in core_hypo[k1].keys()
        ])
        # the latter will result in some DMRs being included even though they have different directions
        # in practice, all of these are in esc_esc_dmrs, i.e. they vary between the two references
        core_discordant[k1] = {}
        for k in u_all.values()[0]:
            core_discordant[k1][k] = setops.reduce_intersection(*[u_all[r][k] for r in esc_samples]).difference(
                core[k1][k]
            )

        n_core[k1] = dict([
            (k, len(v)) for k, v in core[k1].items()
        ])
        n_core_hypo[k1] = dict([
            (k, len(v)) for k, v in core_hypo[k1].items()
        ])
        n_core_hyper[k1] = dict([
            (k, len(v)) for k, v in core_hyper[k1].items()
        ])


    # look across our samples and Weltner samples, keeping only 'double core' DMRs
    # (in BOTH ESC comparisons and in all lines)
    # either look at only 2 / 5 of our samples:
    core_dmrs_ours_hypo_permute_2 = dict([
        (y, setops.reduce_intersection(*[core_hypo[k_our_ipsc][x] for x in y]))
        for y in itertools.combinations(core_hypo[k_our_ipsc].keys(), 2)
    ])
    core_dmrs_ours_hyper_permute_2 = dict([
        (y, setops.reduce_intersection(*[core_hyper[k_our_ipsc][x] for x in y]))
        for y in itertools.combinations(core_hyper[k_our_ipsc].keys(), 2)
    ])
    # or all 5
    core_dmrs_ours_hypo_all = setops.reduce_intersection(*core_hypo[k_our_ipsc].values())
    core_dmrs_ours_hyper_all = setops.reduce_intersection(*core_hyper[k_our_ipsc].values())
    core_dmrs_ours_all = setops.reduce_intersection(*core[k_our_ipsc].values())

    core_dmrs_e6194_hypo = setops.reduce_intersection(*core_hypo[k_e6194_ipsc].values())
    core_dmrs_e6194_hyper = setops.reduce_intersection(*core_hyper[k_e6194_ipsc].values())

    # plot the numbers of DMRs between iPSC and ESC in each study
    df_hyper = pd.concat([pd.DataFrame(dict(val=n_core_hyper[k1], typ=k1)) for k1 in n_core_hyper])
    df_hypo = pd.concat([pd.DataFrame(dict(val=n_core_hypo[k1], typ=k1)) for k1 in n_core_hypo])

    gs = plt.GridSpec(nrows=2, ncols=2, width_ratios=[3, 1])
    fig = plt.figure(figsize=(6, 6))
    axs = np.empty((2, 2), dtype=object)
    fontsize = 12

    ax = fig.add_subplot(gs[1, 0])
    axs[1, 0] = ax
    sns.swarmplot(
        x='typ',
        y='val',
        data=df_hypo.loc[~df_hypo.typ.str.contains('Banovich')],
        ax=ax,
        edgecolor='k',
        linewidth=1.5,
        color='w'
    )
    sns.boxplot(
        x='typ',
        y='val',
        data=df_hypo.loc[~df_hypo.typ.str.contains('Banovich')],
        ax=ax,
        whis="range",
        color='#b2df8a'
    )

    plt.setp(ax.xaxis.get_label(), visible=False)
    ax.set_ylabel('Hypomethylated DMRs', fontsize=fontsize)
    ylim = ax.get_ylim()
    ax.set_ylim([0, ylim[1]])
    xticklabels = [t.get_text().replace(' (', '\n(') for t in ax.get_xticklabels()]
    ax.set_xticklabels(xticklabels, fontsize=fontsize)
    plt.setp(ax.get_yticklabels(), fontsize=fontsize)

    ax = fig.add_subplot(gs[1, 1])
    axs[1, 1] = ax
    sns.swarmplot(
        x='typ',
        y='val',
        data=df_hypo.loc[df_hypo.typ.str.contains('Banovich')],
        ax=ax,
        edgecolor='k',
        linewidth=1.5,
        color='w'
    )
    sns.boxplot(
        x='typ',
        y='val',
        data=df_hypo.loc[df_hypo.typ.str.contains('Banovich')],
        ax=ax,
        whis="range",
        color='#b2df8a'
    )
    plt.setp(ax.xaxis.get_label(), visible=False)
    plt.setp(ax.yaxis.get_label(), visible=False)
    ylim = ax.get_ylim()
    ax.set_ylim([0, ylim[1]])
    xticklabels = [t.get_text().replace(' (', '\n(') for t in ax.get_xticklabels()]
    ax.set_xticklabels(xticklabels, fontsize=fontsize)
    plt.setp(ax.get_yticklabels(), fontsize=fontsize)

    ax = fig.add_subplot(gs[0, 0])
    axs[0, 0] = ax
    sns.swarmplot(
        x='typ',
        y='val',
        data=df_hyper.loc[~df_hyper.typ.str.contains('Banovich')],
        ax=ax,
        edgecolor='k',
        linewidth=1.5,
        color='w'
    )
    sns.boxplot(
        x='typ',
        y='val',
        data=df_hyper.loc[~df_hyper.typ.str.contains('Banovich')],
        ax=ax,
        whis="range",
        color='#fb9a99'
    )
    plt.setp(ax.xaxis.get_label(), visible=False)
    plt.setp(ax.xaxis.get_ticklabels(), visible=False)
    ax.set_ylabel('Hypermethylated DMRs', fontsize=fontsize)
    plt.setp(ax.get_yticklabels(), fontsize=fontsize)

    ax = fig.add_subplot(gs[0, 1])
    axs[0, 1] = ax
    sns.swarmplot(
        x='typ',
        y='val',
        data=df_hyper.loc[df_hyper.typ.str.contains('Banovich')],
        ax=ax,
        edgecolor='k',
        linewidth=1.5,
        color='w'
    )
    sns.boxplot(
        x='typ',
        y='val',
        data=df_hyper.loc[df_hyper.typ.str.contains('Banovich')],
        ax=ax,
        whis="range",
        color='#fb9a99'
    )
    plt.setp(ax.xaxis.get_label(), visible=False)
    plt.setp(ax.yaxis.get_label(), visible=False)
    plt.setp(ax.xaxis.get_ticklabels(), visible=False)
    plt.setp(ax.get_yticklabels(), fontsize=fontsize)

    fig.tight_layout()
    fig.savefig(os.path.join(outdir, "n_common_dmrs_ipsc_vs_esc.png"), dpi=200)
    fig.savefig(os.path.join(outdir, "n_common_dmrs_ipsc_vs_esc.tiff"), dpi=200)

    # resample the larger datasets to equalise the number of lines being considered
    # n_sample = len(ipsc_samples['ours'])

    n_sample = 5
    n_iter = 1000
    hypo_core = {}
    hyper_core = {}
    permuts_hyper_core_n = {}
    permuts_hypo_core_n = {}

    for k1, obj in to_plot.items():
        this_n = len(obj.values()[0])
        u_hypo = {}
        u_hyper = {}
        for j, (r, s) in enumerate(esc_samples.items()):
            t = get_dmr_number_direction(obj[r])
            u = get_dmr_cid_direction(obj[r])
            u_hypo[r] = dict([(k.split('-')[0], x['Hypomethylated']) for k, x in u.items()])
            u_hyper[r] = dict([(k.split('-')[0], x['Hypermethylated']) for k, x in u.items()])

        u_hypo_core = dict([
            (k, setops.reduce_intersection(*[u_hypo[r][k] for r in esc_samples])) for k in u_hypo.values()[0].keys()
        ])
        u_hyper_core = dict([
            (k, setops.reduce_intersection(*[u_hyper[r][k] for r in esc_samples])) for k in
            u_hyper.values()[0].keys()
        ])

        if this_n > n_sample:
            print "Downsampling %s samples (from %d retaining %d)" % (
                k1,
                this_n,
                n_sample
            )
            this_permuts_hypo_n = []
            this_permuts_hyper_n = []
            for i in range(n_iter):
                # keys are same for hypo and hyper
                ix = np.random.permutation(this_n)[:n_sample]
                this_permuts_hypo_n.append(
                    len(setops.reduce_intersection(*[u_hypo_core.values()[a] for a in ix]))
                )
                this_permuts_hyper_n.append(
                    len(setops.reduce_intersection(*[u_hyper_core.values()[a] for a in ix]))
                )
            permuts_hypo_core_n[k1] = this_permuts_hypo_n
            permuts_hyper_core_n[k1] = this_permuts_hyper_n

        else:
            hypo_core[k1] = setops.reduce_intersection(*u_hypo_core.values())
            hyper_core[k1] = setops.reduce_intersection(*u_hyper_core.values())

    # This next part needs to be adjusted depending on the samples being plotted
    fmax = 0.999
    fig, axs = plt.subplots(nrows=2, ncols=1, figsize=(6.5, 8.2))

    sns.violinplot(pd.DataFrame(permuts_hypo_core_n), bw=0.5, ax=axs[0], color=colours[1])
    sns.violinplot(pd.DataFrame(permuts_hyper_core_n), bw=0.5, ax=axs[1], color=colours[0])
    plt.setp(axs[0].xaxis.get_ticklabels(), visible=False)

    markers = ['o', 's']
    xi = range(len(permuts_hypo_core_n))

    for i, (k1, v1) in enumerate(hypo_core.items()):
        axs[0].scatter(
            xi,
            [len(v1)] * len(xi),
            edgecolors='k',
            marker=markers[i],
            facecolors='none',
            label=None,
            lw=1.5,
            zorder=100
        )

    for i, (k1, v1) in enumerate(hyper_core.items()):
        axs[1].scatter(
            xi,
            [len(v1)] * len(xi),
            edgecolors='k',
            marker=markers[i],
            facecolors='none',
            label=k1,
            lw=1.5,
            zorder=100
        )

    axs[1].legend(loc='upper right')
    axs[0].set_ylim([-.5, axs[0].get_ylim()[1]])
    axs[1].set_ylim([-.5, axs[1].get_ylim()[1]])

    axs[0].set_ylabel("Number hypomethylated DMRs")
    axs[1].set_ylabel("Number hypermethylated DMRs")

    fig.tight_layout()
    fig.savefig(os.path.join(outdir, "num_core_dmrs_ipsc_vs_esc_resample.png"), dpi=200)

    # Is there any overlap between the resultant core sets?
    core_dmrs_hypo = {}
    core_dmrs_hyper = {}
    for k1, obj in to_plot.items():
        u_hypo = {}
        u_hyper = {}
        for k2, df in obj.items():
            u = get_dmr_cid_direction(df)
            u_hypo[k2] = setops.reduce_intersection(*[x['Hypomethylated'] for x in u.values()])
            u_hyper[k2] = setops.reduce_intersection(*[x['Hypermethylated'] for x in u.values()])
        core_dmrs_hypo[k1] = setops.reduce_intersection(*u_hypo.values())
        core_dmrs_hyper[k1] = setops.reduce_intersection(*u_hyper.values())


    # outcome
    vs, vc = setops.venn_from_arrays(*core_dmrs_hypo.values())
    print "Hypomethylated core DMRs (hypo in both ESC comparisons). "
    print "Of the %d DMRs in our data, %d are shared with all other refs" % (
        len(core_dmrs_hypo[k_our_ipsc]),
        vc[''.join(['1'] * len(ipsc_vs_esc))]
    )

    vs, vc = setops.venn_from_arrays(*core_dmrs_hyper.values())
    print "Hypermethylated core DMRs (hyper in both ESC comparisons). "
    print "Of the %d DMRs in our data, %d are shared with all other refs" % (
        len(core_dmrs_hyper[k_our_ipsc]),
        vc[''.join(['1'] * len(ipsc_vs_esc))]
    )

    # ESC vs ESC: for context, how many DMRs are there?

    # all possible ESC pairings
    esc_pairs_seen = set()
    esc_esc_dmrs = set()
    for r1 in esc_samples:
        for r2 in esc_samples:
            if r1 != r2 and tuple(sorted([r1, r2])) not in esc_pairs_seen:
                # here we assume that there is only ONE comparison for each case - may need to change this
                the_res = esc_vs_esc[r1][r2].values()[0]
                hypo = ((the_res.padj < fdr) & (the_res.median_delta < 0)).sum()
                hyper = ((the_res.padj < fdr) & (the_res.median_delta > 0)).sum()
                print "Comparison %s - %s. %d hypo DMRs, %d hyper DMRs." % (
                    r1, r2, hypo, hyper
                )
                esc_pairs_seen.add(tuple(sorted([r1, r2])))
                esc_esc_dmrs.update(the_res.index[the_res.padj < fdr])


    # Divide iPSC - ESC core DMRs into 'de novo' and 'residual' based on differences between iPSC, ESC and FB
    # In each case, we repackage the iPSC - FB results so that they are keyed by the equivalent iPSC line
    # For this, we will need to exclude any DMRs that also exist between the two ESCs.

    # Our DMRs: only compare with parental lines
    ipsc_esc_core = core_dmrs(ipsc_vs_esc, fdr=fdr)

    ipsc_fb_ours = {}
    for k, df in ipsc_vs_fb['ours']['ours'].items():
        ii, jj = k.split('-')
        if ii.replace('iPSC', '') == jj.replace('FB', ''):
            ipsc_fb_ours[ii] = df.loc[df.padj < fdr]

    # UPDATE: no longer excluding DMRs that are also DMRs in the ESC-ESC comparison
    # In practice, this makes little difference
    # core_dmr_classified_ours = classify_dmrs_residual_denovo(ipsc_esc_core['ours'], ipsc_fb_ours, exclude=esc_esc_dmrs)
    core_dmr_classified_ours = classify_dmrs_residual_denovo(ipsc_esc_core['ours'], ipsc_fb_ours, exclude=None)
    core_dmr_classified_count_ours = dict(
        [(k, v.classification.value_counts()) for k, v in core_dmr_classified_ours.items()]
    )

    # export to CSV format (one file per patient)
    # also generate a list of genes linked to DMRs in residual hypomethylated regions
    residual_hypo_genes = {}
    for k, v in core_dmr_classified_ours.items():
        v.to_csv(os.path.join(outdir, "%s_classified_dmrs.csv" % k))
        genes = sorted(set(
            v.loc[v.classification == 'hypo_residual', 'genes'].apply(make_tuple).sum()
        ))
        residual_hypo_genes[k] = genes

    # Other matching comparisons
    ipsc_fb_e6194 = {}
    for k, df in ipsc_vs_fb['e6194']['e6194'].items():
        ii, jj = k.split('-')
        if re.search(r'HEL(140|141)', ii):
            ipsc_fb_e6194[ii] = df.loc[df.padj < fdr]

    # core_dmr_classified_e6194 = classify_dmrs_residual_denovo(ipsc_esc_core['e6194'], ipsc_fb_e6194, exclude=esc_esc_dmrs)
    core_dmr_classified_e6194 = classify_dmrs_residual_denovo(ipsc_esc_core['e6194'], ipsc_fb_e6194, exclude=None)
    core_dmr_classified_count_e6194 = dict(
        [(k, v.classification.value_counts()) for k, v in core_dmr_classified_e6194.items()]
    )

    # look up within these results to determine whether the core DMRs are predominantly de novo...
    classified_double_core_ours = dict(
        [(k, v.loc[core_dmrs_ours_hypo_all].classification) for k, v in core_dmr_classified_ours.items()]
    )
    classified_double_core_e6194 = dict(
        [(k, v.loc[core_dmrs_e6194_hypo].classification) for k, v in core_dmr_classified_e6194.items()]
    )

    # combine these results to generate bar charts
    set_colours_hypo = ['#b2df8a', '#33a02c']
    set_colours_hyper = ['#fb9a99', '#e31a1c']
    plot_colours = {'hypo': set_colours_hypo[::-1], 'hyper': set_colours_hyper[::-1]}

    df1 = pd.DataFrame(core_dmr_classified_count_ours)
    df2 = pd.DataFrame(core_dmr_classified_count_e6194)
    df = pd.concat((df1, df2), axis=1).transpose()

    fig, axs = plt.subplots(2, 1, sharex=True, figsize=(4.5, 5))
    for i, typ in enumerate(['hyper', 'hypo']):
        ax = axs[i]
        this = df.loc[:, df.columns.str.contains(typ)].transpose()
        this.index = ['De novo', 'Residual']
        bar.stacked_bar_chart(this, colours=plot_colours[typ], ax=ax, width=0.8, ec='k', lw=1.0)
        ax.set_ylabel('%s DMRs' % ('Hypomethylated' if typ == 'hypo' else 'Hypermethylated'))
        plt.setp(ax.xaxis.get_ticklabels(), rotation=90)

    fig.tight_layout()
    fig.savefig(os.path.join(outdir, "number_dmr_residual_denovo.png"), dpi=200)
    fig.savefig(os.path.join(outdir, "number_dmr_residual_denovo.tiff"), dpi=200)

    # load iPSC, FB, iNSC data (only ours) + ESC
    with open(os.path.join(basedir, "comparisons.txt"), 'rb') as f:
        comps = list(csv.reader(f, delimiter=':'))
    dat_m = {}
    for nm, s1, s2 in comps:
        n1, n2 = nm.split('-')
        if re.search(ipsc_regex['ours'], n1) and s1 not in dat_m:
            for s in s1.split(','):
                if s not in dat_m:
                    dat_m[s] = pd.read_csv(os.path.join(basedir, "%s.csv.gz" % s), header=None, index_col=0)
                    dat_m[s].columns = [s]
        if re.search(insc_regex['ours'], n1) and s1 not in dat_m:
            for s in s1.split(','):
                if s not in dat_m:
                    dat_m[s] = pd.read_csv(os.path.join(basedir, "%s.csv.gz" % s), header=None, index_col=0)
                    dat_m[s].columns = [s]
        if re.search(fb_regex['ours'], n2) and s2 not in dat_m:
            for s in s2.split(','):
                if s not in dat_m:
                    dat_m[s] = pd.read_csv(os.path.join(basedir, "%s.csv.gz" % s), header=None, index_col=0)
                    dat_m[s].columns = [s]
        if (re.search(esc_regex['e6194'], n2) or re.search(esc_regex['encode'], n2)) and s2 not in dat_m:
            for s in s2.split(','):
                if s not in dat_m:
                    dat_m[s] = pd.read_csv(os.path.join(basedir, "%s.csv.gz" % s), header=None, index_col=0)
                    dat_m[s].columns = [s]
    dat_m['GIBCONSC_P4'] = pd.read_csv(os.path.join(basedir, 'GIBCONSC_P4.csv.gz'), header=None, index_col=0)
    dat_m['GIBCONSC_P4'].columns = ['GIBCONSC_P4']

    dat_m = pd.concat(dat_m.values(), axis=1)

    # load clusters
    with open(os.path.join(basedir, 'dmr_clusters.pkl'), 'rb') as f:
        clusters = pickle.load(f)

    # pick one of our samples and show how the residual / de novo meth shows up
    for chosen_one in colour_by_pid:
        chosen_ones_ipsc = dat_m.columns[dat_m.columns.str.contains('DURA%s' % chosen_one) & dat_m.columns.str.contains('IPSC')]
        chosen_ones_insc = dat_m.columns[dat_m.columns.str.contains('DURA%s' % chosen_one) & dat_m.columns.str.contains('NSC')]
        chosen_ones_fb = dat_m.columns[dat_m.columns.str.contains('DURA%s' % chosen_one) & dat_m.columns.str.contains('FB')]
        escs_1 = dat_m.columns[dat_m.columns.str.contains('_H9_')]
        escs_2 = dat_m.columns[dat_m.columns.str.contains('H7')]

        clas = core_dmr_classified_ours['iPSC%s' % chosen_one]

        # 1a. scatter, all probes: iPSC-ESC vs FB-ESC
        fig, ax = scatter_probe_mvals_classified(
            clas,
            dat_m,
            clusters,
            chosen_ones_fb,
            chosen_ones_ipsc,
            escs_1,
            n_other=500
        )
        ax.set_xlabel('M value of FB relative to ESC')
        ax.set_ylabel('M value of iPSC relative to ESC')
        fig.tight_layout()
        fig.savefig(os.path.join(outdir, "ipsc_vs_fb_vs_esc_classified_probes_%s.png" % chosen_one), dpi=200)
        fig.savefig(os.path.join(outdir, "ipsc_vs_fb_vs_esc_classified_probes_%s.tiff" % chosen_one), dpi=200)

        # 1b. scatter, all clusters: iPSC-ESC vs FB-ESC
        fig, ax = scatter_cluster_mvals_classified(
            clas,
            dat_m,
            clusters,
            chosen_ones_fb,
            chosen_ones_ipsc,
            escs_1,
            n_other=200
        )
        ax.set_xlabel('M value of FB relative to ESC')
        ax.set_ylabel('M value of iPSC relative to ESC')
        fig.tight_layout()
        fig.savefig(os.path.join(outdir, "ipsc_vs_fb_vs_esc_classified_clusters_%s.png" % chosen_one), dpi=200)
        fig.savefig(os.path.join(outdir, "ipsc_vs_fb_vs_esc_classified_clusters_%s.tiff" % chosen_one), dpi=200)

        # 2a. scatter: iNSC - ESC vs iPSC - ESC
        fig, ax = scatter_probe_mvals_classified(
            clas,
            dat_m,
            clusters,
            chosen_ones_insc,
            chosen_ones_ipsc,
            escs_1,
            n_other=500
        )
        ax.set_xlabel('M value of FB relative to ESC')
        ax.set_ylabel('M value of iPSC relative to ESC')
        fig.tight_layout()
        fig.savefig(os.path.join(outdir, "insc_vs_ipsc_vs_esc_classified_probes_%s.png" % chosen_one), dpi=200)
        fig.savefig(os.path.join(outdir, "insc_vs_ipsc_vs_esc_classified_probes_%s.tiff" % chosen_one), dpi=200)

        # 2b. scatter, all clusters: iNSC - ESC vs iPSC - ESC
        fig, ax = scatter_cluster_mvals_classified(
            clas,
            dat_m,
            clusters,
            chosen_ones_insc,
            chosen_ones_ipsc,
            escs_1,
            n_other=200
        )
        ax.set_xlabel('M value of iNSC relative to ESC')
        ax.set_ylabel('M value of iPSC relative to ESC')
        fig.tight_layout()
        fig.savefig(os.path.join(outdir, "ipsc_vs_insc_vs_esc_classified_clusters_%s.png" % chosen_one), dpi=200)
        fig.savefig(os.path.join(outdir, "ipsc_vs_insc_vs_esc_classified_clusters_%s.tiff" % chosen_one), dpi=200)

    # New plots for the Dumas paper
    # TODO: move these to a separate module if straightforward
    # these colours are different to those used elsewhere as seaborn 'mutes' the palette, so these are matched
    colour_by_direction = {
        'hypo': '#A5C389',
        'hyper': '#EFA6A5',
    }

    # Quantify feature membership of core iPSC-ESC (ours)
    vs_hyper, vc_hyper = setops.venn_from_arrays(*core_hyper[k_our_ipsc].values(), set_labels=core_hyper[k_our_ipsc].keys())
    vs_hypo, vc_hypo = setops.venn_from_arrays(*core_hypo[k_our_ipsc].values(), set_labels=core_hypo[k_our_ipsc].keys())
    qfm_hyper = setops.quantify_feature_membership(vc_hyper)
    qfm_hypo = setops.quantify_feature_membership(vc_hypo)

    fig = plt.figure(figsize=(5, 3.5))
    ax = fig.add_subplot(111)
    fontsize = 12
    bar.grouped_bar_chart(
        [qfm_hyper, qfm_hypo],
        ax=ax,
        colours=[colour_by_direction['hyper'], colour_by_direction['hypo']],
        edgecolor='k',
        linewidth=1.,
        labels=['Hypermethylation', 'Hypomethylation']
    )
    plt.setp(ax.xaxis.get_ticklabels(), rotation=0, fontsize=fontsize)
    plt.setp(ax.yaxis.get_ticklabels(), fontsize=fontsize)
    ax.set_xlabel('Number of patients sharing DMR', fontsize=fontsize)
    ax.set_ylabel('Frequency', fontsize=fontsize)
    ax.legend(frameon=False, fontsize=fontsize)
    fig.tight_layout()
    fig.savefig(os.path.join(outdir, "our_dmr_sharing_frequency.png"), dpi=200)
    fig.savefig(os.path.join(outdir, "our_dmr_sharing_frequency.tiff"), dpi=200)
    fig.savefig(os.path.join(outdir, "our_dmr_sharing_frequency.pdf"))

    # Combine with gene expression / DE to determine if there is any effect

    # compare our iPSC-ESC with the list of variable genes (at the level of DNA meth) reported by
    # Bock et al. (Cell 2011)
    bock_var_genes = [
        'TF', 'CAT', 'CD14', 'S100A6', 'LEFTY2', 'MEG3', 'DAZL'
    ]
    bock_overlap = {}
    for g in bock_var_genes:
        this = []
        for k, v in ipsc_esc_core['ours'].items():
            t = v.loc[v.genes.str.contains(g), ['median_delta_encode', 'median_delta_e6194', 'genes']]
            if len(t) > 0:
                t.insert(0, 'cluster_id', t.index)
                t.index = [k] * t.shape[0]
            this.append(t)
        bock_overlap[g] = pd.concat(this, axis=0)
