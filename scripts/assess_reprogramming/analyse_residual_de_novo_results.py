"""
Here we load the results generated by running `run_one_comparison.py`. This script outputs one result file per
comparison. We'll load them in and analyse the combined results.
"""

from methylation import loader
from plotting import venn, common
import pandas as pd
from utils import output, setops, log
import numpy as np
import multiprocessing as mp
from matplotlib import pyplot as plt, gridspec
import seaborn as sns
import os
import re
import csv
import collections
from scipy import stats
from settings import OUTPUT_DIR


logger = log.get_console_logger("analyse_residual_dmrs")


def get_dmr_number_direction(res_dict, alpha=0.01):
    out = {}
    for k, this_res in res_dict.items():
        ix1 = this_res.loc[:, 'median_delta'] < 0
        ix2 = this_res.loc[:, 'padj'] < alpha
        out[k] = {
            'Hypermethylated': ((~ix1) & ix2).sum(),
            'Hypomethylated': (ix1 & ix2).sum(),
        }
    return pd.DataFrame(out).transpose()


def get_dmr_cid_direction(res_dict):
    out = {}
    for k, this_res in res_dict.items():
        ix1 = this_res.loc[:, 'median_delta'] < 0
        ix2 = this_res.loc[:, 'padj'] < alpha
        out[k] = {
            'Hypermethylated': this_res.loc[((~ix1) & ix2)].index,
            'Hypomethylated': this_res.loc[(ix1 & ix2)].index,
        }
    return out



def jitter_points(x, spacing_buffer=1, jitter_step=0.02):
    curr = 0
    prev = -1e9
    out = np.zeros_like(x, dtype=float)
    for i in np.argsort(x):
        if np.abs(x[i] - prev) > spacing_buffer:
            curr = max(0., curr - jitter_step)
        else:
            curr += jitter_step
        out[i] = curr
        prev = x[i]
    return out


if __name__ == "__main__":
    indir = os.path.join(OUTPUT_DIR, "assess_reprog_alt1_apocrita", "results")
    outdir = output.unique_output_dir('assess_reprog_alt1_apocrita')
    names = [t.replace('.csv', '') for t in os.listdir(indir) if '.csv' in t]

    fdr = 0.01

    colours = {
        'Hypermethylated': '#e09191',  # red
        'Hypomethylated': '#91e097',  # green
    }

    colour_by_pid = {
        '019': '#7fc97f',
        '030': '#beaed4',
        '031': '#fdc086',
        '050': '#ffff99',
        '054': '#386cb0',
    }

    # split into comparison types
    ipsc_vs_fb_names = [t for t in names if re.match(r'iPSC[^-]*-FB.*', t)]
    ipsc_vs_esc_names = [t for t in names if re.match(r'iPSC[^-]*-ESC.*', t)]
    insc_vs_ipsc_names = [t for t in names if re.match(r'iNSC[^-]*-iPSC.*', t)]
    esc_vs_esc_names = [t for t in names if re.match(r'ESC[^-]*-ESC.*', t)]

    all_types = [
        ipsc_vs_esc_names,
        ipsc_vs_fb_names,
        insc_vs_ipsc_names,
        esc_vs_esc_names
    ]

    if sum([len(t) for t in all_types]) != len(names):
        logger.warn("Some comparisons not covered")

    # now load the actual results
    ipsc_ours_regex = r'iPSC0[135].*'
    fb_ours_regex = r'FB0[135]*'
    ipsc_e6194_regex = r'iPSCHEL[^-]*'
    fb_e6194_regex = r'FB27_HFF'
    ipsc_hipsci_regex = r'iPSCHPS[^-]*'
    ipsc_banov_regex = r'iPSCNA[0-9].*'
    esc_encode_regex = r'ESCH7 hESC'
    esc_e6194_regex = r'ESCH9_p50'
    insc_ours_regex = r'iNSC0[135].*'

    ipsc_regex = {
        'ours': ipsc_ours_regex,
        'e6194': ipsc_e6194_regex,
        'hipsci': ipsc_hipsci_regex,
        'banov': ipsc_banov_regex
    }

    fb_regex = {
        'ours': fb_ours_regex,
        'e6194': fb_e6194_regex
    }

    esc_regex = {
        'encode': esc_encode_regex,
        'e6194': esc_e6194_regex
    }

    insc_regex = {
        'ours': insc_ours_regex
    }

    ipsc_vs_fb = {}
    for k1, v1 in ipsc_regex.items():
        for k2, v2 in fb_regex.items():
            the_regex = re.compile("%s-%s" % (v1, v2))
            the_names = [t for t in ipsc_vs_fb_names if re.match(the_regex, t)]

            ipsc_vs_fb.setdefault(k1, {})[k2] = dict([
                (t, pd.read_csv(os.path.join(indir, "%s.csv" % t), header=0, index_col=0)) for t in the_names
            ])

    ipsc_vs_esc = {}
    for k1, v1 in ipsc_regex.items():
        for k2, v2 in esc_regex.items():
            the_regex = re.compile("%s-%s" % (v1, v2))
            the_names = [t for t in ipsc_vs_esc_names if re.match(the_regex, t)]

            ipsc_vs_esc.setdefault(k1, {})[k2] = dict([
                (t, pd.read_csv(os.path.join(indir, "%s.csv" % t), header=0, index_col=0)) for t in the_names
            ])

    insc_vs_ipsc = {}
    for k1, v1 in insc_regex.items():
        for k2, v2 in ipsc_regex.items():
            the_regex = re.compile("%s-%s" % (v1, v2))
            the_names = [t for t in insc_vs_ipsc_names if re.match(the_regex, t)]

            insc_vs_ipsc.setdefault(k1, {})[k2] = dict([
                (t, pd.read_csv(os.path.join(indir, "%s.csv" % t), header=0, index_col=0)) for t in the_names
            ])

    esc_vs_esc = {}
    for k1, v1 in esc_regex.items():
        for k2, v2 in esc_regex.items():
            the_regex = re.compile("%s-%s" % (v1, v2))
            the_names = [t for t in esc_vs_esc_names if re.match(the_regex, t)]

            esc_vs_esc.setdefault(k1, {})[k2] = dict([
                (t, pd.read_csv(os.path.join(indir, "%s.csv" % t), header=0, index_col=0)) for t in the_names
            ])

    # get lists of sample names
    ipsc_samples = {}
    fb_samples = {}
    esc_samples = {}
    insc_samples = {}

    for i in ipsc_vs_fb:
        for j in ipsc_vs_fb[i]:
            all_ipsc = sorted(set([t.split('-')[0] for t in ipsc_vs_fb[i][j]]))
            all_fb = sorted(set([t.split('-')[1] for t in ipsc_vs_fb[i][j]]))
            ipsc_samples[i] = all_ipsc
            fb_samples[j] = all_fb

    for i in ipsc_vs_esc:
        for j in ipsc_vs_esc[i]:
            all_esc = sorted(set([t.split('-')[1] for t in ipsc_vs_esc[i][j]]))
            esc_samples[j] = all_esc

    for i in insc_vs_ipsc:
        all_insc = sorted(set([t.split('-')[0] for t in insc_vs_ipsc[i]['ours']]))
        insc_samples[i] = all_insc

    ## iPSC vs FB ##

    # 1) is there any obvious increased similarity between matched and unmatached comparisons in our lines?
    t = get_dmr_number_direction(ipsc_vs_fb['ours']['ours'])

    matched = {}
    unmatched = {}

    for k in t.index:
        p1, p2 = k.replace('iPSC', '').replace('FB', '').split('-')
        if p2 == p1:
            the_dict = matched
            loc = 0.
            scale = 0.
        else:
            the_dict = unmatched
            loc = 1.
            scale = 0.05

        y = t.loc[k, 'Hypomethylated']
        the_dict.setdefault('hypo', {}).setdefault(p1, []).append(y)
        y = t.loc[k, 'Hypermethylated']
        the_dict.setdefault('hyper', {}).setdefault(p1, []).append(y)

    spacings = {
        'hypo': 2,
        'hyper': 7,
    }
    fig, axs = plt.subplots(1, 2, sharex=True)
    y = {}
    c = {}
    for pid in unmatched['hypo'].keys():
        for i, k in enumerate(['hypo', 'hyper']):
            ax = axs[i]
            this_y = unmatched[k][pid]
            y.setdefault(k, []).extend(this_y)
            this_c = [colour_by_pid[pid]] * len(this_y)
            c.setdefault(k, []).extend(this_c)
            ax.scatter(
                [0.],
                matched[k][pid],
                marker='o',
                facecolor=colour_by_pid[pid],
                s=40,
                edgecolor='k',
                linewidths=1.0,
                label=pid
            )

    for i, k in enumerate(['hypo', 'hyper']):
        ax = axs[i]
        this_y = y[k]
        this_x = jitter_points(this_y, spacing_buffer=spacings[k], jitter_step=0.05) + 1.
        this_c = c[k]
        ax.scatter(
            this_x,
            this_y,
            marker='o',
            facecolors=this_c,
            s=40,
            edgecolor='k',
            linewidths=1.0,
        )

    for ax in axs:
        ax.set_xlim([-.5, 1.5])
        ax.set_xticks([0, 1])
        ax.set_xticklabels(['Matched', 'Cross-compared'])
        ax.set_ylim([0, ax.get_ylim()[1]])

    axs[0].set_title("Hypomethylated DMRs")
    axs[0].set_ylabel("Number of DMRs")
    axs[1].set_title("Hypermethylated DMRs")
    axs[1].legend(loc='lower right', facecolor='w', framealpha=0.6, frameon=True)

    fig.tight_layout()
    fig.savefig(os.path.join(outdir, "our_ipsc_vs_our_fb_number_dmrs.png"), dpi=200)

    # confidence intervals
    alpha = 0.95
    for pid in matched['hypo']:
        for k in ['hypo', 'hyper']:
            arr = unmatched[k][pid]
            ci = stats.norm.interval(alpha, loc=np.mean(arr), scale=np.std(arr, ddof=1))
            if ci[0] <= matched[k][pid][0] <= ci[1]:
                pass
            else:
                print "%s %s %s -> %d" % (pid, k, str(ci), matched[k][pid][0])
                print "Patient %s, %s DMRs, reject H0 at %.1f%% level." % (pid, k, alpha * 100)

    # 2) numbers and direction

    # to_plot nesting format: iNSC then FB
    k_our_fb = 'Our data (n=%d)' % len(fb_samples['ours'])
    k_e6194_fb = 'E-MTAB-6194 (n=%d)' % len(fb_samples['e6194'])
    k_our_ipsc = 'Our data (n=%d)' % len(ipsc_samples['ours'])
    k_e6194_ipsc = 'E-MTAB-6194 (n=%d)' % len(ipsc_samples['e6194'])
    k_hipsci_ipsc = 'HipSci (n=%d)' % len(ipsc_samples['hipsci'])
    k_banov_ipsc = 'Banovich (n=%d)' % len(ipsc_samples['banov'])

    to_plot = {
        k_our_ipsc: {
            k_our_fb: ipsc_vs_fb['ours']['ours'],
            k_e6194_fb: ipsc_vs_fb['ours']['e6194']
        },
        k_e6194_ipsc: {
            k_our_fb: ipsc_vs_fb['e6194']['ours'],
            k_e6194_fb: ipsc_vs_fb['e6194']['e6194'],
        },
        k_hipsci_ipsc: {
            k_our_fb: ipsc_vs_fb['hipsci']['ours'],
            k_e6194_fb: ipsc_vs_fb['hipsci']['e6194'],
        },
        k_banov_ipsc: {
            k_our_fb: ipsc_vs_fb['banov']['ours'],
            k_e6194_fb: ipsc_vs_fb['banov']['e6194'],
        }
    }


    fig_hypo, axs_hypo = plt.subplots(len(to_plot), len(to_plot.values()[0]), sharex=True, sharey=True, figsize=(3.5, 6))
    fig_hyper, axs_hyper = plt.subplots(len(to_plot), len(to_plot.values()[0]), sharex=True, sharey=True, figsize=(3.5, 6))

    medianprops = dict(linestyle='-', linewidth=2., color='k')

    ymax = {}

    for i, (k1, d) in enumerate(to_plot.items()):
        axs_hyper[i, 0].set_ylabel(k1)
        axs_hypo[i, 0].set_ylabel(k1)
        for j, (k2, obj) in enumerate(d.items()):
            t = get_dmr_number_direction(obj)
            for axs, k3 in zip([axs_hyper, axs_hypo], ['Hypermethylated', 'Hypomethylated']):
                this_y = t.loc[:, k3].values
                this_x = np.random.normal(scale=0.05, size=this_y.size) + 1
                ymax[k3] = max(ymax.get(k3, 0), this_y.max())
                axs[-1, j].set_xlabel(k2)
                ax = axs[i, j]
                bplot = ax.boxplot(
                    this_y,
                    vert=True,
                    patch_artist=True,
                    medianprops=medianprops,
                    widths=0.7
                )
                ax.scatter(this_x, this_y, facecolor='none', edgecolor='k', linewidths=1., s=40, marker='o', zorder=5)
                ax.set_xticks([])
                plt.setp(bplot['boxes'], facecolor=colours[k3])

    axs_hyper[0, 0].set_ylim([0, ymax['Hypermethylated'] * 1.1])
    axs_hypo[0, 0].set_ylim([0, ymax['Hypomethylated'] * 1.1])
    fig_hyper.tight_layout()
    fig_hypo.tight_layout()
    fig_hyper.savefig(os.path.join(outdir, "iPSC_vs_FB_number_dmr_hyper.png"), dpi=200)
    fig_hypo.savefig(os.path.join(outdir, "iPSC_vs_FB_number_dmr_hypo.png"), dpi=200)

    # 3) Overlap of core DMRs in each comparison type
    # Remove (n=x) from labels to save space on the plot
    to_plot2 = {}

    for k1 in to_plot:
        for k2 in to_plot[k1]:
            new_k1 = re.sub(r" \(n=[0-9]*\)", "", k1)
            new_k2 = re.sub(r" \(n=[0-9]*\)", "", k2)
            to_plot2.setdefault(new_k1, {})[new_k2] = to_plot[k1][k2]

    members = {'hypo': {}, 'hyper': {}}
    for i, (k1, d) in enumerate(to_plot2.items()):
        for j, (k2, obj) in enumerate(d.items()):
            t = get_dmr_cid_direction(obj)
            hypo_cid = setops.reduce_intersection(*[x['Hypomethylated'] for x in t.values()])
            hyper_cid = setops.reduce_intersection(*[x['Hypermethylated'] for x in t.values()])
            members['hypo'][(k1, k2)] = hypo_cid
            members['hyper'][(k1, k2)] = hyper_cid

    ks = sorted(members['hypo'].keys())
    upset_dat = [members['hypo'][k] for k in ks]
    upset_lbl = ["%s - %s" % t for t in ks]
    ups = venn.upset_set_size_plot(
        upset_dat, upset_lbl, n_plot=25
    )
    ups['gs'].update(wspace=0.7)
    ups['axes']['set_size'].set_xlabel('Number hypomethylated DMRs in iPSC')
    ups['axes']['main'].set_ylabel('Number DMRs')
    ups['figure'].savefig(os.path.join(outdir, "ipsc_vs_fb_core_hypo_dmr_upset.png"), dpi=200)

    ks = sorted(members['hyper'].keys())
    upset_dat = [members['hyper'][k] for k in ks]
    upset_lbl = ["%s - %s" % t for t in ks]
    ups = venn.upset_set_size_plot(
        upset_dat, upset_lbl, n_plot=25
    )
    ups['gs'].update(wspace=0.7)
    ups['axes']['set_size'].set_xlabel('Number hypermethylated DMRs in iPSC')
    ups['axes']['main'].set_ylabel('Number DMRs')
    ups['figure'].savefig(os.path.join(outdir, "ipsc_vs_fb_core_hyper_dmr_upset.png"), dpi=200)

    ## iPSC vs ESC ##
    # 1) Numbers and direction

    to_plot = {
        k_our_ipsc: ipsc_vs_esc['ours'],
        k_e6194_ipsc: ipsc_vs_esc['e6194'],
        k_hipsci_ipsc: ipsc_vs_esc['hipsci'],
        k_banov_ipsc: ipsc_vs_esc['banov'],
    }

    lbl_map = {
        'encode': 'Encode',
        'e6194': 'Weltner et al.'
    }

    ax1 = None
    gs = plt.GridSpec(2 * len(to_plot), 3)
    fig = plt.figure(figsize=(5, 2 * len(to_plot)))
    axs = np.empty((len(to_plot), 3), dtype=object)
    colours = ['#e09191', '#91e097']  # red, green (hyper, hypo)

    medianprops = dict(linestyle='-', linewidth=2., color='k')

    for i, (k1, obj) in enumerate(to_plot.items()):
        ax1 = None
        ax_i = (2 * i)
        u_hypo = {}
        u_hyper = {}
        for j, (r, s) in enumerate(esc_samples.items()):
            t = get_dmr_number_direction(obj[r])
            u = get_dmr_cid_direction(obj[r])

            if ax1 is None:
                ax = fig.add_subplot(gs[ax_i:(ax_i + 2), j])
                ax1 = ax
            else:
                ax = fig.add_subplot(gs[ax_i:(ax_i + 2), j], sharex=ax1, sharey=ax1)
                # ax = fig.add_subplot(gs[ax_i:(ax_i + 2), j], sharex=ax1)

            if j != 0:
                plt.setp(
                    ax.yaxis.get_ticklabels(), visible=False
                )

            axs[i, j] = ax
            u_hypo[r] = setops.reduce_intersection(*[x['Hypomethylated'] for k, x in u.items()])
            u_hyper[r] = setops.reduce_intersection(*[x['Hypermethylated'] for k, x in u.items()])

            # this_t = t.loc[t.index.str.contains(r)]
            # ax = axs[i, j]
            sns.boxplot(
                data=t.values,
                orient='v',
                # patch_artist=True,
                # medianprops=medianprops,
                width=0.7,
                ax=ax
            )
            # boxes = bplot['boxes']
            boxes = ax.artists

            ax.set_xticks([])

            for p, c in zip(boxes, colours):
                p.set_facecolor(c)

        # add third column with Venn diagrams
        ax = fig.add_subplot(gs[ax_i + 1, 2], facecolor='none', frame_on=False, xticks=[], yticks=[])
        set_labels = None
        if i == (len(to_plot) - 1):
            set_labels = [lbl_map[x] for x in u_hypo.keys()]
        v = venn.venn_diagram(
            *u_hypo.values(),
            ax=ax,
            set_labels=set_labels,
            set_colors=[colours[1]] * 2
        )
        if set_labels is not None:
            plt.setp(v[0].set_labels, fontsize=12)

        ax = fig.add_subplot(gs[ax_i, 2], facecolor='none', frame_on=False, xticks=[], yticks=[])
        set_labels = None
        v = venn.venn_diagram(
            *u_hyper.values(),
            ax=ax,
            set_labels=set_labels,
            set_colors=[colours[0]] * 2,
            alpha=0.7
        )

    for i, (k1, obj) in enumerate(to_plot.items()):
        axs[i, 0].set_ylabel(k1)

    for j, k in enumerate(to_plot.values()[0].keys()):
        axs[-1, j].set_xlabel(lbl_map[k])

    gs.update(bottom=0.05, top=0.96, right=0.97, wspace=0.05)
    fig.savefig(os.path.join(outdir, "iPSC_vs_ESC_number_dmr.png"), dpi=200)

    # KS test: for each PAIR of iPSC lines, and each ESC line, is there evidence that the NUMBERS of DMRs are not
    # similarly distributed?
    ## TODO

    # final piece of information: is there any overlap between the resultant core sets?
    core_dmrs_hypo = {}
    core_dmrs_hyper = {}
    for k1, obj in to_plot.items():
        u_hypo = {}
        u_hyper = {}
        for k2, df in obj.items():
            u = get_dmr_cid_direction(df)
            u_hypo[k2] = setops.reduce_intersection(*[x['Hypomethylated'] for x in u.values()])
            u_hyper[k2] = setops.reduce_intersection(*[x['Hypermethylated'] for x in u.values()])
        core_dmrs_hypo[k1] = setops.reduce_intersection(*u_hypo.values())
        core_dmrs_hyper[k1] = setops.reduce_intersection(*u_hypo.values())


    # outcome
    vs, vc = setops.venn_from_arrays(*core_dmrs_hypo.values())
    print "Hypomethylated core DMRs (hypo in both ESC comparisons). "
    print "Of the %d DMRs in our data, %d are shared with both HipSci and E-MTAB-6194" % (
        len(core_dmrs_hypo[k_our_ipsc]),
        vc['111']
    )

    vs, vc = setops.venn_from_arrays(*core_dmrs_hyper.values())
    print "Hypermethylated core DMRs (hyper in both ESC comparisons). "
    print "Of the %d DMRs in our data, %d are shared with both HipSci and E-MTAB-6194" % (
        len(core_dmrs_hyper[k_our_ipsc]),
        vc['111']
    )
