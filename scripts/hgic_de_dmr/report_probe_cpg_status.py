"""
This script is designed to report the (aggregated) CpG Island participation status for each gene patient in GBM and NSC (and FFPE?)

The unit of analysis is a gene, and we use concordant DMRs to link probes to one or more genes. Only concordant DMRs
with significant differential methylation between  iNSC and GBM are retained. Of these, we aggregate over all samples
(typically just 2 replicates) and all probes (however many are in the combined DMRs) to get a single beta value for
that gene and cell type.

For simplicity, we'll start the analysis with a previously generated list.
"""

import pandas as pd
from methylation import loader
import numpy as np
import os
import collections
from utils import output, setops
from methylation import dmr, process
from scripts.hgic_de_dmr.two_strategies_grouped_dispersion import dmr_results_hash, paired_dmr, load_methylation


if __name__ == "__main__":

    outdir = output.unique_output_dir("report_probe_cpg_dist")

    # this file is generated by two_strategies_grouped_dispersion
    fn = '~/Dropbox/research/qmul/results/hgic_two_strategies/2018-04-10/s1/full_de_dmr_concordant.xlsx'
    dat = pd.read_excel(fn)
    pids = dat.columns[dat.columns.str.contains(r'^[0-9][0-9][0-9]$')].tolist()

    # also load or compute the DMR results and probe data
    DMR_LOAD_DIR = os.path.join(output.OUTPUT_DIR, 'dmr')
    dmr_params = {
        'd_max': 400,
        'n_min': 6,
        'delta_m_min': 1.4,
        'alpha': 0.01,
        'dmr_test_method': 'mwu',  # 'mwu', 'mwu_permute'
        'test_kwargs': {},
    }
    norm_method_s1 = 'swan'

    ############
    # 2: DMRs  #
    ############

    # load raw methylation data
    me_obj, anno = load_methylation(pids, norm_method=norm_method_s1)
    me_data = process.beta_from_m(me_obj.data)
    me_meta = me_obj.meta

    # use a hash on the PIDs and parameters to ensure we're looking for the right results
    dmr_hash_dict = dict(dmr_params)
    dmr_hash_dict['norm_method'] = norm_method_s1

    the_hash = dmr_results_hash(me_obj.meta.index.tolist(), dmr_hash_dict)
    filename = 'dmr_results_paired_comparison.%d.pkl' % the_hash
    fn = os.path.join(DMR_LOAD_DIR, filename)

    if os.path.isfile(fn):
        dmr_res_s1 = dmr.DmrResultCollection.from_pickle(fn, anno=anno)
    else:
        dmr_res_s1 = paired_dmr(me_data, me_meta, anno, pids, dmr_params)
        # Save DMR results to disk
        dmr_res_s1.to_pickle(fn, include_annotation=False)
        print "Saved DMR results to %s" % fn



    # median_beta = collections.OrderedDict()

    # 1) background and DM probe IDs for each patient
    pid_sets = {
        'background': {},
        'dmr': {},
        'hypo': {},
        'hyper': {},
    }

    n_dmr_by_direction = {}

    for pid in pids:
        n_dmr_by_direction[pid] = {'hyper': 0, 'hypo': 0}
        for k, v in pid_sets.items():
            if k == 'background':
                v[pid] = set(me_data.index)
            else:
                v[pid] = set()

        the_dmr_res = dmr_res_s1[pid]
        idx = dat[pid] == 'Y'
        the_genes = dat.loc[idx, 'gene'].values
        the_clusters = dat.loc[idx, 'dmr_cluster_id'].values

        for i, c in enumerate(the_clusters):
            the_probe_ids = the_dmr_res.clusters[c].pids

            pid_sets['background'][pid].difference_update(the_probe_ids)
            pid_sets['dmr'][pid].update(the_probe_ids)

            if the_dmr_res.results[c]['median_change'] > 0:
                # hypermethylation
                pid_sets['hyper'][pid].update(the_probe_ids)
                n_dmr_by_direction[pid]['hyper'] += 1
            else:
                # hypomethylation
                pid_sets['hypo'][pid].update(the_probe_ids)
                n_dmr_by_direction[pid]['hypo'] += 1

    # 2) Add count columns to the (gene / cluster) pairs in dat
    k_open_sea = 'open_sea'
    cats = {
        'N_Shore': 'n_shore',
        'S_Shore': 's_shore',
        'Island': 'island',
        'N_Shelf': 'n_shelf',
        'S_Shelf': 's_shelf',
        k_open_sea: 'open_sea',
    }

    new_cols = ["%s_count" % t for t in cats.values()]
    new_dat = {}
    for pid in pids:
        for t in new_cols:
            new_dat["%s_%s" % (pid, t)] = []

    n_probes = []
    for i, row in dat.iterrows():
        g = row.gene
        cid = row.dmr_cluster_id
        a = the_dmr_res.clusters[cid]
        probe_ids = a.pids
        n_probes.append(len(probe_ids))

        for pid in pids:
            if row[pid] == 'N':
                # this patient does not have this DMR
                for t in new_cols:
                    new_dat["%s_%s" % (pid, t)].append(None)
            else:
                # relevant DMR - go through probes
                this_counts = anno.loc[probe_ids, 'Relation_to_UCSC_CpG_Island'].fillna(k_open_sea).value_counts().to_dict()
                for k, t in cats.items():
                    new_dat["%s_%s_count" % (pid, t)].append(this_counts.get(k, 0))

    for pid in pids:
        # get insertion index
        ix = dat.columns.tolist().index("%s_dmr_padj" % pid) + 1
        for t in new_cols:
            the_k = "%s_%s" % (pid, t)
            dat.insert(ix, the_k, new_dat[the_k])

    dat.insert(2, "n_probe", n_probes)
    dat.to_excel(os.path.join(outdir, "full_de_dmr_concordant.with_cpg_annotation.xlsx"))

    # 3) Similar to above, but compute the _distribution_ across those features in the foreground and background
    res_focus = {}
    res_background = {}
    res_hypo = {}
    res_hyper = {}

    res = {}

    for pid_typ, pid_set in pid_sets.items():
        for pid in pids:
            p = pid_set[pid]
            this_counts = anno.loc[p, 'Relation_to_UCSC_CpG_Island'].fillna(k_open_sea).value_counts().to_dict()
            res.setdefault(pid_typ, {})[pid] = dict([
                (v, this_counts.get(k, 0)) for k, v in cats.items()
            ])

    # sanity check
    for pid in pids:
        if not (pd.Series(res['hyper'][pid]) + pd.Series(res['hypo'][pid]) == pd.Series(res['dmr'][pid])).all():
            raise ValueError("PID %s failed check # hypo + # hyper = # dmr" % pid)

    # all
    this_counts = anno.loc[:, 'Relation_to_UCSC_CpG_Island'].fillna(k_open_sea).value_counts().to_dict()
    res_all = dict([
        (v, this_counts.get(k, 0)) for k, v in cats.items()
    ])

    # save this in a 'nice' format for sharing
    cols = cats.values()
    to_export = pd.DataFrame(
        index=pd.MultiIndex.from_product([pids, res.keys()], names=['patient ID', 'probe list']),
        columns=cols
    )

    for pid_typ, pid_set in res.items():
        for pid in pids:
            to_export.loc[(pid, pid_typ)] = pd.Series(pid_set[pid])[cols]

    to_export.loc[('all', 'all'), cols] = pd.Series(res_all)[cols]

    to_export.to_excel(os.path.join(outdir, "cpg_annotation_distribution_by_dmr_type.xlsx"))


    #         g = the_genes[i]
    #         a = the_dmr_res.clusters[c]
    #
    #         this_res_cluster_count[g] += 1
    #         this_res_probe_count[g] += len(a.pids)
    #
    #         for t in ['GBM', 'DURA']:
    #             this_res.setdefault(t, {})
    #             the_dat = me_data.loc[a.pids, me_data.columns.str.contains('%s%s' % (t, pid))]
    #             if g in this_res[t]:
    #                 this_res[t][g] = pd.concat((this_res[t][g], the_dat), axis=0)
    #             else:
    #                 this_res[t][g] = the_dat
    #
    #     for t in ['GBM', 'DURA']:
    #         for g in this_res[t]:
    #             this_res_median.setdefault(t, {})[g] = np.median(this_res[t][g].values)
    #
    #     median_beta['GBM%s' % pid] = pd.Series(this_res_median['GBM'])
    #     median_beta['NSC%s' % pid] = pd.Series(this_res_median['DURA'])
    #
    # all_genes = sorted(setops.reduce_union(*[t.index for t in median_beta.values()]))
    # all_median = pd.DataFrame(index=all_genes, columns=median_beta.keys())
    #
    # i = 2
    # for pid in pids:
    #     this_genes = median_beta['GBM%s' % pid].index
    #     all_median.loc[this_genes, 'GBM%s' % pid] = median_beta['GBM%s' % pid]
    #     all_median.loc[this_genes, 'NSC%s' % pid] = median_beta['NSC%s' % pid]
    #     d = pd.Series(index=all_genes)
    #     d.loc[this_genes[
    #         (median_beta['GBM%s' % pid] > median_beta['NSC%s' % pid]).values
    #     ]] = 'Hyper'
    #     d.loc[this_genes[
    #         (median_beta['GBM%s' % pid] < median_beta['NSC%s' % pid]).values
    #     ]] = 'Hypo'
    #     all_median.insert(i, '%s_direction' % pid, d)
    #     i += 3
    #
    # all_median.to_excel(os.path.join(outdir, 'median_beta_by_gene.xlsx'))