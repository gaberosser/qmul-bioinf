"""
This script is designed to report the (aggregated) CpG Island participation status for each gene patient in GBM and NSC (and FFPE?)

The unit of analysis is a gene, and we use concordant DMRs to link probes to one or more genes. Only concordant DMRs
with significant differential methylation between  iNSC and GBM are retained. Of these, we aggregate over all samples
(typically just 2 replicates) and all probes (however many are in the combined DMRs) to get a single beta value for
that gene and cell type.

For simplicity, we'll start the analysis with a previously generated list.
"""

import pandas as pd
import numpy as np
import os
from plotting import bar
from utils import output, setops
from methylation import dmr, process
from scripts.hgic_de_dmr.two_strategies_grouped_dispersion import dmr_results_hash, paired_dmr, load_methylation
from scripts.hgic_final import consts
from settings import INTERMEDIATE_DIR


if __name__ == "__main__":

    outdir = output.unique_output_dir("report_probe_cpg_dist")

    # key used to name the cluster ID column
    # k_cid = 'dmr_cluster_id'
    k_cid = 'cluster_id'

    pids = consts.PIDS

    # also load or compute the DMR results and probe data
    DMR_LOAD_DIR = os.path.join(INTERMEDIATE_DIR, 'dmr')
    dmr_params = {
        'd_max': 400,
        'n_min': 6,
        'delta_m_min': 1.4,
        'alpha': 0.01,
        'dmr_test_method': 'mwu',  # 'mwu', 'mwu_permute'
        'test_kwargs': {},
    }
    norm_method_s1 = 'swan'

    ###############
    # Load DMRs   #
    ###############

    # load raw methylation data
    me_obj, anno = load_methylation(pids, norm_method=norm_method_s1)
    me_data = process.beta_from_m(me_obj.data)
    me_meta = me_obj.meta

    # remove unneeded samples
    me_meta = me_meta.loc[me_meta.index != 'DURA061_NSC_N6_P4']
    me_meta = me_meta.loc[me_meta.type.isin(['GBM', 'iNSC', 'NSC'])]
    me_data = me_data.loc[:, me_meta.index]

    # use a hash on the PIDs and parameters to ensure we're looking for the right results
    dmr_hash_dict = dict(dmr_params)
    dmr_hash_dict['norm_method'] = norm_method_s1

    the_hash = dmr_results_hash(me_obj.meta.index.tolist(), dmr_hash_dict)
    filename = 'dmr_results_paired_comparison.%d.pkl' % the_hash
    fn = os.path.join(DMR_LOAD_DIR, filename)

    if os.path.isfile(fn):
        dmr_res_s1 = dmr.DmrResultCollection.from_pickle(fn, anno=anno)
    else:
        dmr_res_s1 = paired_dmr(me_data, me_meta, anno, pids, dmr_params)
        # Save DMR results to disk
        dmr_res_s1.to_pickle(fn, include_annotation=False)
        print "Saved DMR results to %s" % fn

    # this file is generated by two_strategies_grouped_dispersion
    # fn = '~/Dropbox/research/qmul/results/hgic_two_strategies/2018-04-10/s1/full_de_dmr_concordant.xlsx'
    fn = '/home/gabriel/Dropbox/research/qmul/results/hgic_two_strategies/2018-04-10/s1/patient_unique_dmr.xlsx'
    # fn = '~/Dropbox/research/qmul/results/hgic_two_strategies/2018-04-10/s1/full_dmr.xlsx'
    outfile = "%s.with_cpg_island_annotation.xlsx" % os.path.splitext(os.path.split(fn)[1])[0]

    dat = pd.read_excel(fn)

    ############
    # 2: DMRs  #
    ############

    # load raw methylation data
    me_obj, anno = load_methylation(pids, norm_method=norm_method_s1)
    me_data = process.beta_from_m(me_obj.data)
    me_meta = me_obj.meta

    # use a hash on the PIDs and parameters to ensure we're looking for the right results
    dmr_hash_dict = dict(dmr_params)
    dmr_hash_dict['norm_method'] = norm_method_s1

    the_hash = dmr_results_hash(me_obj.meta.index.tolist(), dmr_hash_dict)
    filename = 'dmr_results_paired_comparison.%d.pkl' % the_hash
    fn = os.path.join(DMR_LOAD_DIR, filename)

    if os.path.isfile(fn):
        dmr_res_s1 = dmr.DmrResultCollection.from_pickle(fn, anno=anno)
    else:
        dmr_res_s1 = paired_dmr(me_data, me_meta, anno, pids, dmr_params)
        # Save DMR results to disk
        dmr_res_s1.to_pickle(fn, include_annotation=False)
        print "Saved DMR results to %s" % fn

    # 1) background and DM probe IDs for each patient
    pid_sets = {
        'background': {},
        'dmr': {},
        'hypo': {},
        'hyper': {},
    }

    n_dmr_by_direction = {}

    for pid in pids:
        n_dmr_by_direction[pid] = {'Hyper': 0, 'Hypo': 0}
        for k, v in pid_sets.items():
            if k == 'background':
                v[pid] = set(me_data.index)
            else:
                v[pid] = set()

        the_dmr_res = dmr_res_s1[pid]
        idx = dat[pid] == 'Y'
        the_clusters = dat.loc[idx, k_cid].values

        for i, c in enumerate(the_clusters):
            the_probe_ids = the_dmr_res.clusters[c].pids

            pid_sets['background'][pid].difference_update(the_probe_ids)
            pid_sets['dmr'][pid].update(the_probe_ids)

            if the_dmr_res.results[c]['median_change'] > 0:
                # hypermethylation
                pid_sets['hyper'][pid].update(the_probe_ids)
                n_dmr_by_direction[pid]['Hyper'] += 1
            else:
                # hypomethylation
                pid_sets['hypo'][pid].update(the_probe_ids)
                n_dmr_by_direction[pid]['Hypo'] += 1


    for_plot = pd.DataFrame.from_dict(n_dmr_by_direction)[[
        '017', '019', '030', '031', '018', '050', '054', '061', '026', '052'
    ]].loc[['Hypo', 'Hyper']]
    for_plot_pct = for_plot.divide(for_plot.sum(), axis=1) * 100.
    colours = pd.Series({'Hyper': '#FF381F', 'Hypo': '#89CD61'})

    fig, ax = bar.stacked_bar_chart(for_plot_pct, colours=colours)
    ax.set_ylabel("Percentage of clusters")
    ax.set_ylim([0, 100])
    # shrink main axis and put legend on RHS
    box = ax.get_position()
    ax.set_position([box.x0, box.y0, box.width * 0.9, box.height])
    ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    fig.savefig(os.path.join(outdir, "%s.pct_clusters_by_dm_direction.png" % outfile), dpi=200)

    # 2) Add count columns to the (gene / cluster) pairs in dat
    k_open_sea = 'open_sea'
    cats = {
        'N_Shore': 'n_shore',
        'S_Shore': 's_shore',
        'Island': 'island',
        'N_Shelf': 'n_shelf',
        'S_Shelf': 's_shelf',
        k_open_sea: 'open_sea',
    }

    new_cols = ["%s_count" % t for t in cats.values()]
    new_dat = {}
    for pid in pids:
        for t in new_cols:
            new_dat["%s_%s" % (pid, t)] = []

    n_probes = []
    for i, row in dat.iterrows():
        cid = row[k_cid]
        a = the_dmr_res.clusters[cid]
        probe_ids = a.pids
        n_probes.append(len(probe_ids))

        for pid in pids:
            if row[pid] == 'N':
                # this patient does not have this DMR
                for t in new_cols:
                    new_dat["%s_%s" % (pid, t)].append(None)
            else:
                # relevant DMR - go through probes
                this_counts = anno.loc[probe_ids, 'Relation_to_UCSC_CpG_Island'].fillna(k_open_sea).value_counts().to_dict()
                for k, t in cats.items():
                    new_dat["%s_%s_count" % (pid, t)].append(this_counts.get(k, 0))

    for pid in pids:
        # get insertion index: put it at the end of the patient block
        ins_col = dat.columns[dat.columns.str.contains(pid)][-1]
        ix = dat.columns.tolist().index(ins_col) + 1
        for t in new_cols:
            the_k = "%s_%s" % (pid, t)
            dat.insert(ix, the_k, new_dat[the_k])

    dat.insert(2, "n_probe", n_probes)
    dat.to_excel(os.path.join(outdir, outfile))

    # 3) Similar to above, but compute the _distribution_ across those features in the foreground and background
    res = {}

    for pid_typ, pid_set in pid_sets.items():
        for pid in pids:
            p = pid_set[pid]
            this_counts = anno.loc[p, 'Relation_to_UCSC_CpG_Island'].fillna(k_open_sea).value_counts().to_dict()
            res.setdefault(pid_typ, {})[pid] = dict([
                (v, this_counts.get(k, 0)) for k, v in cats.items()
            ])

    # sanity check
    # this DOES fail in one case (031) - there seems to be one probe that is in a hypo AND hyper cluster
    # I guess this is OK in theory - it's just the way that clusters were defined
    for pid in pids:
        if not (pd.Series(res['hyper'][pid]) + pd.Series(res['hypo'][pid]) == pd.Series(res['dmr'][pid])).all():
            print "PID %s failed check # hypo + # hyper = # dmr" % pid

    # all
    this_counts = anno.loc[:, 'Relation_to_UCSC_CpG_Island'].fillna(k_open_sea).value_counts().to_dict()
    res_all = dict([
        (v, this_counts.get(k, 0)) for k, v in cats.items()
    ])

    # save this in a 'nice' format for sharing
    cols = cats.values()
    to_export = pd.DataFrame(
        index=pd.MultiIndex.from_product([pids, res.keys()], names=['patient ID', 'probe list']),
        columns=cols
    )

    for pid_typ, pid_set in res.items():
        for pid in pids:
            to_export.loc[(pid, pid_typ)] = pd.Series(pid_set[pid])[cols]

    to_export.loc[('all', 'all'), cols] = pd.Series(res_all)[cols]

    to_export.to_excel(os.path.join(outdir, "%s.cpg_annotation_distribution.xlsx" % outfile))
