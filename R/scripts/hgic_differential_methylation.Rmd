---
title: "Implementing multiple Differential Methylation Analysis methods"
author: "Gabriel Rosser"
date: "20 February 2019"
output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = TRUE)
opts_knit$set(root.dir = normalizePath('..'))

knitr::opts_chunk$set(echo = TRUE)

require(limma)
require("ChAMP")
require("minfi")
require("wateRmelon")
require("data.table")
require(sva)
require(RColorBrewer)
require(openxlsx)
require(ks)
require("ggplot2")
require("reshape")

# this specifies the normalisation algorithm to use
# norm.fun <- 'swan'
norm.fun <- 'funnorm'

# this is our FDR cutoff
alpha <- 0.01

# This specifies a minimum logFC
min_lfc <- 1.

# see description below
load_preproc <- F
# load_preproc <- T

```

## Load data and prepare metadata

Two options here:

1. Load the data from the raw `idat` files. This ensures that all samples are normalised together for each preparation type. However, it doesn't reflect the DMR process I have used in the past [`load_preproc = FALSE`].
2. Load the data from pre-processed `csv` files. Data were normalised in the batches as they arrived [`load_preproc = TRUE`]. This is quite a lot faster.

**NB** I have tested the effect of these two approaches on the downstream analysis in Python and the results are **not** affected. Therefore, option (2) seems easier.

```{r echo=FALSE}
source('_settings.R')
source("methylation/loader.R")

cc_pids <- c('018', '019', '030', '031', '017', '050', '054', '061', '026', '052')

cc_samples <- c(
  "GBM018_P12",
  "GBM018_P10",
  "DURA018_NSC_N4_P4",
  "DURA018_NSC_N2_P6",
  "GBM019_P4",
  "GBM019_P3n6",
  "DURA019_NSC_N8C_P2",
  "DURA019_NSC_N5C1_P2",
  "GBM030_P9",
  "GBM030_P5",
  "DURA030_NSC_N16B6_P1",
  "DURA030_NSC_N9_P2",
  "GBM031_P7",
  "GBM031_P4",
  "DURA031_NSC_N44B_P2",
  "DURA031_NSC_N44F_P3",
  "GBM017_P3",
  "GBM017_P4",
  "DURA017_NSC_N3C5_P4",
  "GBM050_P7n8",
  "GBM050_P9",
  "DURA050_NSC_N12_P3",
  "DURA050_NSC_N16_P4",
  "GBM054_P4",
  "GBM054_P6",
  "DURA054_NSC_N3C_P2",
  "DURA054_NSC_N2E_P1",
  "GBM061_P3",
  "GBM061_P5",
  "DURA061_NSC_N4_P2",
  "DURA061_NSC_N1_P3n4",
  "GBM026_P8",
  "GBM026_P3n4",
  "DURA026_NSC_N31D_P5",
  "GBM052_P6n7",
  "GBM052_P4n5",
  "DURA052_NSC_N4_P3",
  "DURA052_NSC_N5_P2"
)

cc_base.dirs <- c(
  file.path(data.dir.raid, 'methylation', "2017-05-12"),
  file.path(data.dir.raid, 'methylation', "2016-12-19_ucl_genomics"),
  file.path(data.dir.raid, 'methylation', "2017-09-19"),
  file.path(data.dir.raid, 'methylation', "2018-01-12"),
  file.path(data.dir.raid, 'methylation', "2017-08-23"),
  file.path(data.dir.raid, 'methylation', "2018-04-09")
)

if (load_preproc) {
  cc_beta <- list()
  snames <- NULL
  batches <- NULL
  for (c in cc_base.dirs) {
    this_batch <- split_path(c)[1]
    
    the_fname <- file.path(c, 'beta', paste0('beta_', norm.fun, '.csv.gz'))
    if (! file.exists(the_fname)) {
      stop(sprintf("File not found: %s", the_fname))
    }
    # get header
    hdr <- scan(the_fname, sep=',', nlines=1, what = 'character')
    ix <- hdr %in% cc_samples
    load_cols <- c(1, which(ix))
    snames <- c(snames, hdr[ix])
    batches <- c(batches, rep(this_batch, sum(ix)))
    
    # load only selected data
    this_dat <- fread(sprintf("zcat %s", the_fname), select = load_cols, data.table = F)
    
    # set row names and drop the unneeded col
    rownames(this_dat) <- this_dat[,1]
    this_dat$V1 <- NULL
    
    cc_beta[[c]] <- this_dat
  }
  # reduce to common probes
  common_probes <- Reduce(intersect, lapply(cc_beta, rownames))
  cc_beta <- lapply(cc_beta, function(x) {as.data.frame(t(x[common_probes,]))})
  # bind by row then transpose and restore colnames
  cc_beta <- as.data.frame(t(rbindlist(cc_beta)))
  colnames(cc_beta) <- snames

} else {
  
  lst <- get_filenames_from_batches(cc_base.dirs, cc_samples)

  cc_res <- process_idats(lst$in.files, lst$snames, norm.fun=norm.fun, force = T)
  cc_beta <- cc_res$beta
  
  snames <- lst$snames
  batches <- lst$batches
  
}

cc_m <- MfromBeta(cc_beta)

cc_meta <- data.frame(row.names = snames)
cc_meta$batch <- batches
cc_meta$patient_id <- gsub("[^0-9]*([0-9]{3}).*", "\\1", rownames(cc_meta), perl=T)
cc_meta$cell_type <- "iNSC"
cc_meta[grep('GBM', rownames(cc_meta)), 'cell_type'] <- 'GIC'

if (!load_preproc) {
  # save the data to a file, which we can use from within Python
  write.csv(cc_meta,"hgic_gbm_insc_meta.csv")
  write.csv(cc_m, sprintf("hgic_gbm_insc_mvals_%s.csv", norm.fun))
}



```
## `limma`

This package allows us to build a GLM and identify differentially methylated probes (DMPs). This package was originally designed for gene expression microarrays, but it is also applicable to methylation arrays. We're going to mimic the DE approach by pooling all samples for the purpose of dispersion estimation, then iterating over patient-specific contrasts.

```{r}
pid <- cc_meta$patient_id
ct <- cc_meta$cell_type
group <- paste(pid, ct, sep = '_')

design <- model.matrix(~0 + group)

contrast_string = c()
for (p in cc_pids) {
  a <- paste0("group", p, "_GIC")
  b <- paste0("group", p, "_iNSC")
  contrast_string <- c(contrast_string, paste(a, b, sep = '-'))
}
the_contrasts <- makeContrasts(contrasts = contrast_string, levels=design)

fit.reduced <- lmFit(cc_m, design)

fit.reduced <- contrasts.fit(fit.reduced, the_contrasts)
fit.reduced <- eBayes(fit.reduced, trend = T, robust=T)

res_limma <- list()
for (i in seq(ncol(the_contrasts))) {
  p <- cc_pids[i]
  res_limma[[p]] <- topTable(fit.reduced, coef=i, n=Inf, lfc=min_lfc, p.value = alpha)
}

# plot pct by direction
df <- data.frame(row.names = c('Hyper', 'Hypo'))
for (p in names(res_limma)) {
  n_pos <- sum(res_limma[[p]]$logFC > 0)
  n_neg <- sum(res_limma[[p]]$logFC < 0)
  df[, p] <- c(n_pos, n_neg)
}
df.pct <- t(t(df) / colSums(df)) * 100.

df.long <- melt(as.matrix(df))
colnames(df.long) <- c('Direction', 'Patient', 'Value')
pid_col <- sprintf("%03d", df.long$Patient)
df.long$Patient <- factor(pid_col, levels = cc_pids)

df.pct.long <- melt(df.pct)
colnames(df.pct.long) <- c('Direction', 'Patient', 'Value')
pid_col <- sprintf("%03d", df.pct.long$Patient)
df.pct.long$Patient <- factor(pid_col, levels = cc_pids)

# numbers chart
ggplot(df.long, aes(x=Patient, y=Value, fill=Direction)) + geom_bar(stat='identity') + scale_fill_manual(values=c("#FF381F", "#89CD61")) + labs(title="limma DMP, full list")

# full list bar chart (%)
ggplot(df.pct.long, aes(x=Patient, y=Value, fill=Direction)) + geom_bar(stat='identity') + scale_fill_manual(values=c("#FF381F", "#89CD61")) + labs(title="limma DMP, full list", y='% by direction')

# specific list %
# lapply(pids, function(x) {})

```


## `DMRcate`

This workflow essentially proceeds by first running DMP analysis (in `limma`), then aggregating the outputs.

