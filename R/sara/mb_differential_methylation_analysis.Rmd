---
title: "BMI1 and CHD7 in medullosblastoma primary lines"
subtitle: "Genome-wide DNA methylation analysis"
output: html_notebook
author: "Gabriel Rosser"
---

```{r setup, include=FALSE}
require("knitr")
opts_knit$set(root.dir = normalizePath('..'))

knitr::opts_chunk$set(echo = TRUE)

require(limma)
require("ChAMP")
require("minfi")
require("wateRmelon")
require("data.table")
require(RColorBrewer)
require(openxlsx)

MVALUE_FN <- "m_values_1299_3021.xlsx"
META_FN <- "metadata_1299_3021.csv"

```

Check for the required input Excel file. Create it if necessary (from the raw idat files). We should only need to do this once.

```{r echo=FALSE}

if (!file.exists(MVALUE_FN) | !(file.exists(META_FN))) {
  writeLines(
    paste0(c("The input Excel file", MVALUE_FN, "was not found. Computing from raw idats."), collapse = " ")
  )

  source('io/output.R')
  source('_settings.R')
  source("utils.R")
  
  MfromBeta <- function(beta) {
    log2(beta / (1 - beta))
  }
  
  split_path <- function(x) if (dirname(x)==x) x else c(basename(x),split_path(dirname(x)))
  
  get_idat_basenames <- function(idat.dir) {
    #' Get the basename of all idat files found recursively under the provided directory
    #' The basename is the full path, minus the trailing _Red.idat
    flist <- list.files(path = idat.dir, recursive = T)
    flist <- flist[grep('_Red.idat', flist)]
    
    # convert to basenames for loading
    basenames <- file.path(idat.dir, sub(pattern = "_Red.idat", "", flist))
  }
  
  
  process_idats <- function(
    in.files,
    snames,
    norm.fun=c('swan', 'bmiq', 'funnorm', 'quantile', 'pbc', 'raw'),
    arraytype='EPIC'
  ) {
    norm.fun = match.arg(norm.fun)
    rgSet <- read.metharray(in.files, extended = T)
    colnames(rgSet) <- snames
    
    mset <- preprocessRaw(rgSet)
    detP <- detectionP(rgSet)
    
    # Load beta values (raw), then apply default ChAMP filtering
    beta.raw <- getBeta(mset, "Illumina")
    champLoad <- champ.filter(beta.raw, detP = detP, pd = NULL, arraytype = arraytype)
    beta.raw <- champLoad$beta
    
    if (norm.fun == 'raw') beta <- beta.raw
    
    if (norm.fun == 'swan') {
      mset.swan <- preprocessSWAN(rgSet, mSet = mset)
      beta.swan <- getBeta(mset.swan)
      beta <- beta.swan[rownames(beta.raw),]
    }
    
    if (norm.fun == 'bmiq') {
      beta <- champ.norm(beta = beta.raw, method = 'BMIQ', arraytype = arraytype, cores=4)
    }
    
    if (norm.fun == 'pbc') {
      beta <- champ.norm(beta = beta.raw, method = 'PBC', arraytype = arraytype)
    }
    
    if (norm.fun == 'funnorm') {
      grSet.funnorm <- preprocessFunnorm(rgSet)
      beta <- getBeta(grSet.funnorm)[rownames(beta.raw),]
    }
    
    if (norm.fun == 'quantile') {
      grSet.quantile <- preprocessQuantile(rgSet)
      beta <- getBeta(grSet.quantile)[rownames(beta.raw),]
    }
    
    return(list(beta.raw=beta.raw, beta=beta))
    
  }

# load data from raw
    
norm.fun <- 'quantile'

failed_filenames <- c(
  "202081130238/202081130238_R01C01"
)
samples <- c(
  'ICb1299_Scr', 
  'ICb1299_shBMI1', 
  'ICb1299_shCHD7', 
  'ICb1299_shBMI1CHD7', 
  'p62_3_shBmi1', 
  'p62_3_shChd7', 
  'p62_3_shB+C',
  'p62_3_Scr', 
  '3021_1_Scr', 
  '3021_1_shB', 
  '3021_1_shC', 
  '3021_1_shB+C',
  'S', 
  'B', 
  'C', 
  'B+C'
)

base.dirs <- c(
  file.path(data.dir.raid, 'methylation', '2017-09-19'),
  file.path(data.dir.raid, 'methylation', '2018-01-12'),
  file.path(data.dir.raid, 'methylation', '2018-03-19'),
  file.path(data.dir.raid, 'methylation', '2018-03-26'),
  file.path(data.dir.raid, 'methylation', '2018-04-09')
)

in.files <- NULL
snames <- NULL
batches <- NULL

for (b in base.dirs) {
  meta <- read.csv(file.path(b, 'sources.csv'))
  # set the rownames as filenames
  rownames(meta) <- paste(meta$Sentrix_ID, meta$Sentrix_Position, sep = '_')
  this_files <- get_idat_basenames(file.path(b, 'idat'))
  
  # reorder meta
  meta <- meta[basename(this_files),]
  
  # filter meta
  idx <- meta[, 'sample'] %in% samples
  
  # define file and sample names and add to list
  this_files <- this_files[idx]
  this_snames <- as.vector(meta[idx, 'sample'])
  this_batches <- as.vector(sapply(this_files, function(x){split_path(x)[4]}))
  
  in.files <- c(in.files, this_files)
  snames <- c(snames, this_snames)
  batches <- c(batches, this_batches)
}

# manually remove a failed sample
idx <- in.files %in% failed_filenames
in.files <- in.files[!idx]
snames <- snames[!idx]
batches <- batches[!idx]

# idx <- grep("202081130238/202081130238_R01C01", in.files)
# in.files <- in.files[-idx]
# snames <- snames[-idx]
# batches <- batches[-idx]

res <- process_idats(in.files, snames, norm.fun=norm.fun)
beta <- res$beta
beta.raw <- res$beta.raw

# simple metadata
meta <- data.frame(row.names = snames)

meta$cell_line <- '3021'
meta[grep('1299', rownames(meta)), 'cell_line'] <- '1299'
meta[grep('p62', rownames(meta)), 'cell_line'] <- '1299'

meta$batch <- batches

meta$condition <- 'Scr'
meta[grep('bmi1', rownames(meta), ignore.case = T), 'condition'] <- 'shBMI1'
meta[grep('shb', rownames(meta), ignore.case = T), 'condition'] <- 'shBMI1'

meta[grep('chd', rownames(meta), ignore.case = T), 'condition'] <- 'shCHD7'
meta[grep('shc', rownames(meta), ignore.case = T), 'condition'] <- 'shCHD7'

meta[grep('\\+', rownames(meta)), 'condition'] <- 'shBMI1shCHD7'
meta[grep('bmi1chd7', rownames(meta), ignore.case = T), 'condition'] <- 'shBMI1shCHD7'
meta[rownames(meta) == 'B', 'condition'] <- 'shBMI1'
meta[rownames(meta) == 'C', 'condition'] <- 'shCHD7'

m <- MfromBeta(beta)

# save M data to Excel file.
write.xlsx(m, MVALUE_FN)
# save metadata to CSV file.
write.csv(meta, META_FN)

} else {
  
  BetafromM <- function(m) {
    (2 ** m) / (1 + 2 ** m)
  }
  
  writeLines(
    paste0(c("Loading pre-computed M data from", MVALUE_FN), collapse = " ")
  )
  m <- read.xlsx(MVALUE_FN)
  beta <- BetafromM(m)
  writeLines(
    paste0(c("Loading pre-computed metadata from", META_FN), collapse = " ")
  )
  meta <- read.csv(META_FN)
}
```

Run a few exploratory checks.

```{r}

densityPlot(beta, sampGroups = meta$batch, ylim = c(0,7))
densityPlot(beta, sampGroups = meta$cell_line, ylim = c(0,7))

pal <- brewer.pal(8,"Dark2")
plotMDS(m, top=NULL, col=pal[factor(meta$batch)])
legend("topright", legend=levels(factor(meta$batch)), text.col=pal, bg="white")

```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
